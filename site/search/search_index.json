{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tsrs - Tree-Shaking in Rust for Python","text":"<p>A high-performance tree-shaking implementation in Rust for Python modules and packages.</p>"},{"location":"#manifesto","title":"Manifesto","text":"<p>\"Ever had someone say, 'just copy the function, we don't need the whole package'? What if that didn't have to be true?\"</p> <p>Tree-shaking enables developers to depend on large, well-designed libraries while only deploying the code they actually use. No more choosing between monolithic packages or duplicating code. Get the best of both worlds: leverage battle-tested libraries while keeping your deployments lean and efficient.</p>"},{"location":"#overview","title":"Overview","text":"<p>Tree-shaking is the process of analyzing code to identify and remove unused exports from Python modules. This project provides a Rust-based implementation that can be used from Python to detect dead code and optimize module sizes.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#cli","title":"CLI","text":"<pre><code># Analyze a virtual environment\n./target/debug/tsrs-cli analyze /path/to/venv\n\n# Create a slim venv from Python code and venv\n./target/debug/tsrs-cli slim &lt;python-directory&gt; &lt;venv-location&gt;\n\n# Create slim venv with custom output path\n./target/debug/tsrs-cli slim &lt;python-directory&gt; &lt;venv-location&gt; -o /path/to/output/.venv-slim\n</code></pre>"},{"location":"#minify-plan-preview","title":"Minify Plan Preview","text":"<pre><code># Inspect planned local renames without rewriting code\n./target/debug/tsrs-cli minify-plan path/to/module.py\n\n# Apply a curated plan to a file (prints to stdout by default)\n./target/debug/tsrs-cli apply-plan path/to/module.py --plan plan.json\n\n# Apply in place with a backup and stats\n./target/debug/tsrs-cli apply-plan path/to/module.py --plan plan.json --in-place --backup-ext .bak --stats --json\n</code></pre>"},{"location":"#safe-local-rename-rewrite","title":"Safe Local Rename Rewrite","text":"<pre><code># Emit rewritten source when safe (no nested scopes/imports)\n./target/debug/tsrs-cli minify path/to/module.py\n\n# Rewrite in place (updates the file on disk)\n./target/debug/tsrs-cli minify path/to/module.py --in-place\n\n# Keep a .bak backup before rewriting in place\n./target/debug/tsrs-cli minify path/to/module.py --in-place --backup-ext .bak\n\n# Inspect rename counts (optionally emit JSON)\n./target/debug/tsrs-cli minify path/to/module.py --stats\n./target/debug/tsrs-cli minify path/to/module.py --stats --json\n</code></pre>"},{"location":"#directory-rewrite","title":"Directory Rewrite","text":"<pre><code># Mirror ./src into ./src-min with minified modules\n./target/debug/tsrs-cli minify-dir ./src\n\n# Write into a custom output directory\n./target/debug/tsrs-cli minify-dir ./src --out-dir ./dist/min\n\n# Only minify application code, skip tests\n./target/debug/tsrs-cli minify-dir ./project \\\n  --include \"project/**\" \\\n  --exclude \"project/tests/**\"\n\n# Preview changes without writing files\n./target/debug/tsrs-cli minify-dir ./src --dry-run\n\n# Rewrite files in place (no mirror directory)\n./target/debug/tsrs-cli minify-dir ./src --in-place\n\n# Rewrite in place and keep .bak backups of originals\n./target/debug/tsrs-cli minify-dir ./src --in-place --backup-ext .bak\n</code></pre> <p>Each run prints per-file status lines (minified, skipped, bailouts) and summarises the total work. Bailouts copy the original file verbatim so you never lose working code\u2014re-run with <code>--debug</code> to inspect why a file could not be safely renamed.</p> <p>Add <code>--stats</code> to include per-file rename counts in the output, and combine it with <code>--json</code> for a machine-readable summary of the same data.</p>"},{"location":"#plan-bundles","title":"Plan Bundles","text":"<pre><code># Create a directory-wide plan bundle\n./target/debug/tsrs-cli minify-plan-dir ./src --out plan.json\n\n# Apply the bundle to a mirrored output tree\n./target/debug/tsrs-cli apply-plan-dir ./src --plan plan.json --out-dir ./src-min\n\n# Apply in place with backups and detailed stats\n./target/debug/tsrs-cli apply-plan-dir ./src --plan plan.json --in-place --backup-ext .bak --stats --json\n\n# CI: fail if a rewrite would change files or introduce bailouts\n./target/debug/tsrs-cli minify-dir ./src --dry-run --fail-on-change --fail-on-bailout\n</code></pre>"},{"location":"#references","title":"References","text":"<ul> <li>pyminifier (liftoffsoftware)</li> <li>TreeShaker (sclabs)</li> <li>\u201cBuild a Python tree-shaker in Rust\u201d (dev.to)</li> <li>\u201cCrude Python tree-shaking for squeezing into AWS Lambda package size limits\u201d (sam152)</li> </ul>"},{"location":"#how-it-works","title":"How it Works","text":"<ol> <li>Scans the Python code directory for all import statements</li> <li>Analyzes the source venv to discover all installed packages</li> <li>Maps imports to packages and copies only the used packages to a new slim venv</li> <li>Creates <code>.venv-slim</code> with only the minimal dependencies needed</li> </ol>"},{"location":"#example","title":"Example","text":"<pre><code># Slim your venv based on actual code usage\ntsrs-cli slim ./src ./.venv\n# Creates: ./.venv-slim with only the packages your code imports\n</code></pre>"},{"location":"#building","title":"Building","text":""},{"location":"#cli-only","title":"CLI Only","text":"<pre><code>cargo build --release --bin tsrs-cli\n./target/release/tsrs-cli --help\n</code></pre>"},{"location":"#with-python-extension","title":"With Python Extension","text":"<p>This project can also build as a Python extension module using PyO3.</p> <pre><code># Setup (optional Python feature)\npip install maturin\n\n# Build and develop\nmaturin develop\n\n# Or build a wheel\nmaturin build --release\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#core-modules","title":"Core Modules","text":"<ul> <li><code>venv</code> - Virtual environment discovery and package analysis</li> <li><code>imports</code> - Import statement extraction and tracking</li> <li><code>callgraph</code> - Function call graph analysis per package</li> <li>Tracks which functions are defined in each package</li> <li>Maps external dependencies between packages</li> <li>Identifies unused/dead code that is never called</li> <li><code>slim</code> - Creates minimal venvs based on code analysis</li> </ul>"},{"location":"#how-tree-shaking-works","title":"How Tree-Shaking Works","text":"<p>The tool builds a complete picture of your code's dependencies:</p> <ol> <li>Import Analysis: Extracts all <code>import</code> and <code>from...import</code> statements from your code</li> <li>Call Graph Building: Analyzes function definitions and calls in your Python code</li> <li>Package Mapping: Maps imports to actual packages in your venv</li> <li>Dead Code Detection: Identifies functions/classes that are defined but never used</li> <li>Dependency Reduction: Creates a slim venv with only the necessary packages</li> </ol> <p>This multi-layered approach ensures you don't accidentally remove code that's used through indirect calls or dynamic imports.</p>"},{"location":"#high-precision-low-recall-philosophy","title":"High Precision, Low Recall Philosophy","text":"<p>tsrs prioritizes precision over recall in dead code detection:</p> <ul> <li>High Precision: When we flag something as dead/unused, it almost certainly is</li> <li>Low Recall: We're happy to miss dead code - better conservative than aggressive</li> </ul> <p>We will keep:</p> <ul> <li>All global variables and module-level constants in any package (these may be used externally or through reflection)</li> <li>All public API surfaces even if not directly called in your code</li> <li>Packages you explicitly import, even if only specific functions are used</li> <li>Any code that could potentially be used (even indirectly)</li> </ul> <p>The philosophy: It's better to leave in unused code than to accidentally break something that's actually used through indirect calls, dynamic imports, reflection, or a library's public API.</p> <p>We're optimizing for correctness over comprehensiveness - we'd rather miss some dead code than introduce false positives that break your application.</p>"},{"location":"#development","title":"Development","text":"<pre><code>cargo test\ncargo fmt\ncargo clippy\n</code></pre>"},{"location":"#references-inspiration","title":"References &amp; Inspiration","text":""},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>Ruff - An extremely fast Python linter written in Rust. Uses <code>ruff_python_parser</code> for parsing Python code.</li> <li>Pylyzer - A fast, feature-rich static code analyzer &amp; language server for Python. Uses Rust internally with type checking capabilities.</li> <li>Skylos - A static analysis tool for Python codebases that detects dead code, unused functions, classes, imports, and variables. Also includes security flaw detection.</li> </ul>"},{"location":"#discussion","title":"Discussion","text":"<ul> <li>Reddit Discussion: Is there any support in Python for something like tree-shaking?</li> </ul>"},{"location":"#license","title":"License","text":"<p>TBD</p>"},{"location":"API/","title":"API Reference","text":"<p>This document describes the public API of the tsrs library for programmatic use.</p>"},{"location":"API/#overview","title":"Overview","text":"<p>The tsrs library provides Rust modules for analyzing Python code and virtual environments. It can be used as a library in other Rust projects or integrated with Python via PyO3.</p>"},{"location":"API/#core-modules","title":"Core Modules","text":""},{"location":"API/#venv-module","title":"venv Module","text":"<p>Analyze Python virtual environments and discover installed packages.</p> <pre><code>use tsrs::venv::{VenvAnalyzer, VenvInfo, PackageInfo};\n\n// Create an analyzer for a virtual environment\nlet analyzer = VenvAnalyzer::new(\"/path/to/.venv\")?;\n\n// Get information about the venv\nlet venv_info = analyzer.analyze()?;\n\n// Print package names\nfor package in &amp;venv_info.packages {\n    println!(\"Package: {}\", package.name);\n    if let Some(version) = &amp;package.version {\n        println!(\"  Version: {}\", version);\n    }\n}\n</code></pre>"},{"location":"API/#venvanalyzer","title":"VenvAnalyzer","text":"<pre><code>pub struct VenvAnalyzer {\n    venv_path: PathBuf,\n}\n\nimpl VenvAnalyzer {\n    /// Create a new venv analyzer\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the venv path does not exist.\n    pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self&gt;;\n\n    /// Analyze the venv and collect package information\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the analysis fails.\n    pub fn analyze(&amp;self) -&gt; Result&lt;VenvInfo&gt;;\n}\n</code></pre>"},{"location":"API/#venvinfo","title":"VenvInfo","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VenvInfo {\n    /// Path to the venv\n    pub path: PathBuf,\n    /// Python version (if detectable)\n    pub python_version: Option&lt;String&gt;,\n    /// List of installed packages\n    pub packages: Vec&lt;PackageInfo&gt;,\n}\n</code></pre>"},{"location":"API/#packageinfo","title":"PackageInfo","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct PackageInfo {\n    /// Package name\n    pub name: String,\n    /// Package version\n    pub version: Option&lt;String&gt;,\n    /// Path to the package\n    pub path: PathBuf,\n}\n</code></pre>"},{"location":"API/#imports-module","title":"imports Module","text":"<p>Extract and track import statements from Python source code.</p> <pre><code>use tsrs::imports::{ImportCollector, ImportSet};\nuse std::path::Path;\n\n// Create a collector\nlet mut collector = ImportCollector::new();\n\n// Collect from a file\ncollector.collect_from_file(\"src/main.py\")?;\n\n// Get all imports\nlet imports = collector.get_imports();\nfor import in imports.get_imports() {\n    println!(\"Import: {}\", import);\n}\n</code></pre>"},{"location":"API/#importcollector","title":"ImportCollector","text":"<pre><code>pub struct ImportCollector {\n    imports: ImportSet,\n}\n\nimpl ImportCollector {\n    /// Create a new import collector\n    #[must_use]\n    pub fn new() -&gt; Self;\n\n    /// Parse a Python file and extract imports\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read or parsed.\n    pub fn collect_from_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;()&gt;;\n\n    /// Parse Python source code and extract imports\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed.\n    pub fn collect_from_source(&amp;mut self, source: &amp;str) -&gt; Result&lt;()&gt;;\n\n    /// Get collected imports\n    #[must_use]\n    pub fn get_imports(&amp;self) -&gt; ImportSet;\n}\n</code></pre>"},{"location":"API/#importset","title":"ImportSet","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct ImportSet {\n    pub imports: HashSet&lt;String&gt;,\n}\n\nimpl ImportSet {\n    /// Create a new import set\n    #[must_use]\n    pub fn new() -&gt; Self;\n\n    /// Add an import\n    pub fn add(&amp;mut self, import: String);\n\n    /// Get all imports\n    #[must_use]\n    pub fn get_imports(&amp;self) -&gt; Vec&lt;String&gt;;\n}\n</code></pre>"},{"location":"API/#callgraph-module","title":"callgraph Module","text":"<p>Analyze function definitions and calls to build call graphs.</p> <pre><code>use tsrs::callgraph::CallGraphAnalyzer;\n\n// Create analyzer\nlet mut analyzer = CallGraphAnalyzer::new()?;\n\n// Analyze a Python file\nanalyzer.analyze_file(\"module.py\", \"mypackage\")?;\n\n// Find unused functions\nlet unused = analyzer.find_unused_functions(\"mypackage\");\nfor func_name in unused {\n    println!(\"Unused: {}\", func_name);\n}\n\n// Find external dependencies\nlet external = analyzer.find_external_dependencies();\nfor dep in external {\n    println!(\"External dependency: {}\", dep);\n}\n</code></pre>"},{"location":"API/#callgraphanalyzer","title":"CallGraphAnalyzer","text":"<pre><code>pub struct CallGraphAnalyzer {\n    graphs: HashMap&lt;String, PackageCallGraph&gt;,\n}\n\nimpl CallGraphAnalyzer {\n    /// Create a new call graph analyzer\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if regex compilation fails.\n    pub fn new() -&gt; Result&lt;Self&gt;;\n\n    /// Analyze a Python file and build call graph\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read.\n    pub fn analyze_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, package: &amp;str) -&gt; Result&lt;()&gt;;\n\n    /// Get all call graphs\n    #[must_use]\n    pub fn get_graphs(&amp;self) -&gt; &amp;HashMap&lt;String, PackageCallGraph&gt;;\n\n    /// Get call graph for a specific package\n    #[must_use]\n    pub fn get_graph(&amp;self, package: &amp;str) -&gt; Option&lt;&amp;PackageCallGraph&gt;;\n\n    /// Find unused functions in a package\n    #[must_use]\n    pub fn find_unused_functions(&amp;self, package: &amp;str) -&gt; HashSet&lt;String&gt;;\n\n    /// Find all external dependencies\n    #[must_use]\n    pub fn find_external_dependencies(&amp;self) -&gt; HashSet&lt;String&gt;;\n}\n</code></pre>"},{"location":"API/#slim-module","title":"slim Module","text":"<p>Create minimal virtual environments based on code analysis.</p> <pre><code>use tsrs::slim::VenvSlimmer;\n\n// Create slimmer with default output\nlet mut slimmer = VenvSlimmer::new(\"./src\", \"./.venv\")?;\nslimmer.slim()?;\n// Creates ./.venv-slim\n\n// Or specify custom output\nlet mut slimmer = VenvSlimmer::new_with_output(\n    \"./src\",\n    \"./.venv\",\n    \"./output/.venv-slim\"\n)?;\nslimmer.slim()?;\n</code></pre>"},{"location":"API/#venvslimmer","title":"VenvSlimmer","text":"<pre><code>pub struct VenvSlimmer {\n    code_directory: PathBuf,\n    source_venv: PathBuf,\n    output_venv: PathBuf,\n}\n\nimpl VenvSlimmer {\n    /// Create a new venv slimmer that analyzes code_directory and slims source_venv\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if either path does not exist.\n    pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(code_directory: P, source_venv: P) -&gt; Result&lt;Self&gt;;\n\n    /// Create a new venv slimmer with custom output path\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if either path does not exist.\n    pub fn new_with_output&lt;P: AsRef&lt;Path&gt;&gt;(\n        code_directory: P,\n        source_venv: P,\n        output_venv: P,\n    ) -&gt; Result&lt;Self&gt;;\n\n    /// Create a slim venv by analyzing code imports and copying only used packages\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the analysis or copying fails.\n    pub fn slim(&amp;self) -&gt; Result&lt;()&gt;;\n}\n</code></pre>"},{"location":"API/#minify-module","title":"minify Module","text":"<p>Analyze and rewrite Python code with minified local variable names.</p> <pre><code>use tsrs::minify::Minifier;\n\n// Create a minification plan\nlet plan = Minifier::plan_from_source(\"mymodule\", source_code)?;\n\n// Rewrite code with the plan\nlet minified = Minifier::rewrite_with_plan(\"mymodule\", source_code, &amp;plan)?;\nprintln!(\"{}\", minified);\n</code></pre>"},{"location":"API/#minifier","title":"Minifier","text":"<pre><code>pub struct Minifier;\n\nimpl Minifier {\n    /// Build a plan for renaming local symbols in every function contained in the source\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed.\n    pub fn plan_from_source(module_name: &amp;str, source: &amp;str) -&gt; Result&lt;MinifyPlan&gt;;\n\n    /// Rewrite source code by applying planned renames when no nested functions are present\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed or planned.\n    pub fn rewrite_source(module_name: &amp;str, source: &amp;str) -&gt; Result&lt;String&gt;;\n\n    /// Rewrite using a precomputed plan, enabling plan curation before application\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed.\n    pub fn rewrite_with_plan(\n        module_name: &amp;str,\n        source: &amp;str,\n        plan: &amp;MinifyPlan,\n    ) -&gt; Result&lt;String&gt;;\n}\n</code></pre>"},{"location":"API/#minifyplan","title":"MinifyPlan","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MinifyPlan {\n    pub module: String,\n    pub keywords: HashSet&lt;String&gt;,\n    pub functions: Vec&lt;FunctionPlan&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FunctionPlan {\n    pub qualified_name: String,\n    pub renames: Vec&lt;RenameEntry&gt;,\n    pub range: Option&lt;FunctionRange&gt;,\n    pub has_nested_functions: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct RenameEntry {\n    pub original: String,\n    pub renamed: String,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\npub struct FunctionRange {\n    pub start: usize,\n    pub end: usize,\n}\n</code></pre>"},{"location":"API/#error-handling","title":"Error Handling","text":"<p>All fallible operations return <code>Result&lt;T&gt;</code>:</p> <pre><code>use tsrs::error::{Result, TsrsError};\n\nmatch some_operation() {\n    Ok(value) =&gt; println!(\"Success: {}\", value),\n    Err(TsrsError::ParseError(msg)) =&gt; eprintln!(\"Parse error: {}\", msg),\n    Err(TsrsError::Io(err)) =&gt; eprintln!(\"IO error: {}\", err),\n    Err(TsrsError::InvalidVenvPath(msg)) =&gt; eprintln!(\"Invalid venv: {}\", msg),\n}\n</code></pre>"},{"location":"API/#examples","title":"Examples","text":""},{"location":"API/#complete-analysis-workflow","title":"Complete Analysis Workflow","text":"<pre><code>use tsrs::{\n    venv::VenvAnalyzer,\n    imports::ImportCollector,\n    callgraph::CallGraphAnalyzer,\n    slim::VenvSlimmer,\n};\n\nfn main() -&gt; tsrs::error::Result&lt;()&gt; {\n    // 1. Analyze venv\n    let analyzer = VenvAnalyzer::new(\"./.venv\")?;\n    let venv_info = analyzer.analyze()?;\n    println!(\"Found {} packages\", venv_info.packages.len());\n\n    // 2. Collect imports from code\n    let mut import_collector = ImportCollector::new();\n    import_collector.collect_from_file(\"./src/main.py\")?;\n    let imports = import_collector.get_imports();\n    println!(\"Found {} imports\", imports.get_imports().len());\n\n    // 3. Build call graph\n    let mut call_graph = CallGraphAnalyzer::new()?;\n    call_graph.analyze_file(\"./src/main.py\", \"myapp\")?;\n    let unused = call_graph.find_unused_functions(\"myapp\");\n    println!(\"Found {} unused functions\", unused.len());\n\n    // 4. Create slim venv\n    let slimmer = VenvSlimmer::new(\"./src\", \"./.venv\")?;\n    slimmer.slim()?;\n    println!(\"Created slim venv\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"API/#thread-safety","title":"Thread Safety","text":"<p>All public types are safe to use across threads. The library uses: - <code>Arc</code> for shared state - <code>Mutex</code> where needed for interior mutability - No global mutable state</p>"},{"location":"API/#performance-notes","title":"Performance Notes","text":"<ul> <li>Parallel Processing: Directory operations use <code>rayon</code> for parallelization</li> <li>Caching: Import sets use <code>HashSet</code> for O(1) lookups</li> <li>Streaming: Large files are streamed where possible</li> <li>Allocation: Minimal allocations in hot paths</li> </ul>"},{"location":"API/#version-compatibility","title":"Version Compatibility","text":"<ul> <li>Rust: 1.75+</li> <li>Python: 3.8+ (for code being analyzed)</li> </ul>"},{"location":"API/#see-also","title":"See Also","text":"<ul> <li>MINIFY_DESIGN.md - Minification algorithm details</li> <li>README.md - Project overview and CLI usage</li> <li>TESTING.md - Testing guide</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to tsrs","text":"<p>Thank you for your interest in contributing to tsrs (Tree-Shaking in Rust for Python)! This document outlines the process for contributing to the project.</p>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and collaborative. We're building a tool to make Python deployments better for everyone.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.75+ (check with <code>rustc --version</code>)</li> <li>Python 3.8+ (for testing)</li> <li>Git</li> </ul>"},{"location":"CONTRIBUTING/#local-development-setup","title":"Local Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/GeorgePearse/tsrs.git\ncd tsrs\n\n# Build the project\ncargo build --release\n\n# Run tests\ncargo test\n\n# Run linting and formatting\ncargo fmt\ncargo clippy -- -W clippy::pedantic\n\n# Check the pre-commit hook runs successfully\n./target/release/tsrs-cli --help\n</code></pre>"},{"location":"CONTRIBUTING/#making-changes","title":"Making Changes","text":""},{"location":"CONTRIBUTING/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a feature branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes with clear, focused commits    <pre><code>git add &lt;files&gt;\ngit commit -m \"Description of changes\"\n</code></pre></p> </li> <li> <p>Ensure code quality <pre><code># Format code\ncargo fmt\n\n# Run linting (this runs automatically in pre-commit hook)\ncargo clippy -- -W clippy::pedantic\n\n# Run tests\ncargo test\n</code></pre></p> </li> <li> <p>Push and open a PR <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"CONTRIBUTING/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<ul> <li>Use clear, descriptive messages</li> <li>Start with a verb (Add, Fix, Refactor, etc.)</li> <li>Reference issues when relevant: <code>Fixes #123</code></li> <li>Example: <code>Add support for nested function analysis in minify module</code></li> </ul>"},{"location":"CONTRIBUTING/#testing-requirements","title":"Testing Requirements","text":"<p>All contributions must include tests:</p> <pre><code># Run all tests\ncargo test\n\n# Run tests with output\ncargo test -- --nocapture\n\n# Run specific test\ncargo test test_name\n</code></pre>"},{"location":"CONTRIBUTING/#code-standards","title":"Code Standards","text":""},{"location":"CONTRIBUTING/#style-guide","title":"Style Guide","text":"<ul> <li>Formatting: Use <code>cargo fmt</code> (enforced via pre-commit hook)</li> <li>Linting: Must pass <code>cargo clippy -- -W clippy::pedantic</code></li> <li>Documentation: Add doc comments to public APIs   <pre><code>/// Brief description\n///\n/// Longer explanation if needed.\n///\n/// # Errors\n///\n/// Describe what errors this function can return.\npub fn my_function() -&gt; Result&lt;T&gt; {\n    // ...\n}\n</code></pre></li> </ul>"},{"location":"CONTRIBUTING/#type-safety","title":"Type Safety","text":"<ul> <li>Write fully typed Python code for Rust implementations</li> <li>Use type annotations in all function signatures</li> <li>Leverage Rust's type system for compile-time safety</li> </ul>"},{"location":"CONTRIBUTING/#project-structure","title":"Project Structure","text":"<pre><code>tsrs/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs              # Library root, public API\n\u2502   \u251c\u2500\u2500 bin/cli.rs          # CLI binary\n\u2502   \u251c\u2500\u2500 venv.rs             # Virtual environment analysis\n\u2502   \u251c\u2500\u2500 imports.rs          # Import statement extraction\n\u2502   \u251c\u2500\u2500 callgraph.rs        # Function call graph analysis\n\u2502   \u251c\u2500\u2500 slim.rs             # Venv slimming implementation\n\u2502   \u251c\u2500\u2500 minify.rs           # Local variable minification\n\u2502   \u251c\u2500\u2500 error.rs            # Error types\n\u2502   \u2514\u2500\u2500 lib.rs              # Library entry point\n\u251c\u2500\u2500 tests/                  # Integration tests\n\u251c\u2500\u2500 Cargo.toml              # Manifest\n\u251c\u2500\u2500 README.md               # Project overview\n\u251c\u2500\u2500 CONTRIBUTING.md         # This file\n\u251c\u2500\u2500 MINIFY_DESIGN.md        # Minify algorithm details\n\u251c\u2500\u2500 TESTING.md              # Testing guide\n\u2514\u2500\u2500 TEST_REPOS_SUMMARY.md   # Test repository documentation\n</code></pre>"},{"location":"CONTRIBUTING/#key-modules","title":"Key Modules","text":""},{"location":"CONTRIBUTING/#venvrs","title":"venv.rs","text":"<p>Analyzes Python virtual environments to discover installed packages and their metadata.</p>"},{"location":"CONTRIBUTING/#importsrs","title":"imports.rs","text":"<p>Parses Python source code to extract <code>import</code> and <code>from...import</code> statements. Uses rustpython-parser for AST analysis.</p>"},{"location":"CONTRIBUTING/#callgraphrs","title":"callgraph.rs","text":"<p>Builds a call graph of functions within packages to identify unused/dead code.</p>"},{"location":"CONTRIBUTING/#slimrs","title":"slim.rs","text":"<p>Creates minimal virtual environments by analyzing code imports and copying only used packages.</p>"},{"location":"CONTRIBUTING/#minifyrs","title":"minify.rs","text":"<p>Implements safe local variable renaming for Python code (minification) while preserving correctness.</p>"},{"location":"CONTRIBUTING/#architecture-decisions","title":"Architecture Decisions","text":""},{"location":"CONTRIBUTING/#high-precision-low-recall-philosophy","title":"High Precision, Low Recall Philosophy","text":"<p>We prioritize correctness over comprehensiveness:</p> <ul> <li>Never remove code unless we're absolutely certain it's unused</li> <li>Keep module-level exports (they may be used externally)</li> <li>Preserve public APIs even if not directly called</li> <li>Be conservative with dynamic features and reflection</li> </ul>"},{"location":"CONTRIBUTING/#error-handling","title":"Error Handling","text":"<ul> <li>Use <code>Result&lt;T&gt;</code> for fallible operations</li> <li>Provide context in error messages</li> <li>Use custom error types via <code>thiserror</code></li> </ul>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":"<p>When adding features, update relevant documentation:</p> <ul> <li>Code comments: Explain the \"why\" not the \"what\"</li> <li>Doc comments: Public API documentation</li> <li>README.md: Update usage examples</li> <li>MINIFY_DESIGN.md: Algorithm or design details</li> <li>TESTING.md: How to test your feature</li> </ul>"},{"location":"CONTRIBUTING/#performance-considerations","title":"Performance Considerations","text":"<p>The project uses: - rayon: Parallel processing for directory operations - rustpython-parser: Fast Python AST parsing - regex: Pattern matching for import statements - walkdir: Efficient directory traversal</p> <p>When optimizing: 1. Profile first with <code>cargo flamegraph</code> 2. Benchmark changes: <code>cargo bench</code> 3. Consider parallelization opportunities</p>"},{"location":"CONTRIBUTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"CONTRIBUTING/#pre-commit-hook-failures","title":"Pre-commit Hook Failures","text":"<p>If the clippy pre-commit hook fails:</p> <pre><code># Run clippy manually to see detailed output\ncargo clippy -- -W clippy::pedantic\n\n# Fix issues or suppress with #[allow(...)] if justified\n# Then try committing again\n</code></pre>"},{"location":"CONTRIBUTING/#test-failures","title":"Test Failures","text":"<pre><code># Run tests with backtrace\nRUST_BACKTRACE=1 cargo test\n\n# Run specific failing test\ncargo test failing_test_name -- --nocapture\n</code></pre>"},{"location":"CONTRIBUTING/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: See README.md, MINIFY_DESIGN.md, TESTING.md</li> <li>Issues: Open an issue on GitHub with details</li> <li>Discussions: Use GitHub Discussions for questions</li> </ul>"},{"location":"CONTRIBUTING/#recognition","title":"Recognition","text":"<p>Contributors will be recognized in the project's CONTRIBUTORS file (once created).</p>"},{"location":"CONTRIBUTING/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as the project (TBD).</p> <p>Thank you for making tsrs better! \ud83d\ude80</p>"},{"location":"MINIFY_DESIGN/","title":"Python Minification Design","text":""},{"location":"MINIFY_DESIGN/#overview","title":"Overview","text":"<p>Scope-aware local renaming for functions using rustpython_parser AST. Collects function-local bindings and generates short names (a, b, c...) while respecting Python scoping rules.</p>"},{"location":"MINIFY_DESIGN/#core-data-structures","title":"Core Data Structures","text":""},{"location":"MINIFY_DESIGN/#functionplan","title":"FunctionPlan","text":"<pre><code>use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FunctionPlan {\n    /// Function name (for debugging/tracking)\n    pub name: String,\n\n    /// Original names in function scope (sorted for stability)\n    pub local_names: Vec&lt;String&gt;,\n\n    /// Mapping from original name to minified name\n    pub rename_map: HashMap&lt;String, String&gt;,\n\n    /// Names that cannot be renamed (globals, nonlocals, builtins, keywords)\n    pub excluded_names: Vec&lt;String&gt;,\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#minifyplan","title":"MinifyPlan","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MinifyPlan {\n    /// Function plans in stable order (by source position)\n    pub functions: Vec&lt;FunctionPlan&gt;,\n\n    /// Python keywords that must never be renamed\n    pub python_keywords: Vec&lt;String&gt;,\n\n    /// Builtin names that should not be renamed\n    pub builtins: Vec&lt;String&gt;,\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#short-name-generator","title":"Short Name Generator","text":"<p>Simple sequential generator: a, b, c, ..., z, aa, ab, ..., zz, aaa, ...</p> <pre><code>pub struct ShortNameGen {\n    counter: usize,\n}\n\nimpl ShortNameGen {\n    pub fn new() -&gt; Self {\n        Self { counter: 0 }\n    }\n\n    pub fn next(&amp;mut self, keywords: &amp;[String]) -&gt; String {\n        loop {\n            let name = Self::generate(self.counter);\n            self.counter += 1;\n\n            if !keywords.contains(&amp;name) {\n                return name;\n            }\n        }\n    }\n\n    fn generate(n: usize) -&gt; String {\n        let mut num = n;\n        let mut result = String::new();\n\n        loop {\n            result.push((b'a' + (num % 26) as u8) as char);\n            num /= 26;\n            if num == 0 {\n                break;\n            }\n            num -= 1;\n        }\n\n        result.chars().rev().collect()\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#python-keywords-complete-list","title":"Python Keywords (Complete List)","text":"<p>Never rename these 35 keywords:</p> <pre><code>const PYTHON_KEYWORDS: &amp;[&amp;str] = &amp;[\n    \"False\", \"None\", \"True\", \"and\", \"as\", \"assert\", \"async\", \"await\",\n    \"break\", \"class\", \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\",\n    \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"in\", \"is\",\n    \"lambda\", \"nonlocal\", \"not\", \"or\", \"pass\", \"raise\", \"return\",\n    \"try\", \"while\", \"with\", \"yield\",\n];\n</code></pre>"},{"location":"MINIFY_DESIGN/#ast-node-types-for-binding-collection","title":"AST Node Types for Binding Collection","text":""},{"location":"MINIFY_DESIGN/#1-function-parameters","title":"1. Function Parameters","text":"<pre><code>// ast::StmtFunctionDef, ast::StmtAsyncFunctionDef\nparameters: Parameters {\n    posonlyargs: Vec&lt;ParameterWithDefault&gt;,  // positional-only\n    args: Vec&lt;ParameterWithDefault&gt;,         // normal params\n    vararg: Option&lt;Parameter&gt;,               // *args\n    kwonlyargs: Vec&lt;ParameterWithDefault&gt;,   // keyword-only\n    kwarg: Option&lt;Parameter&gt;,                // **kwargs\n}\n\n// Extract: .arg (Identifier) from each Parameter\n</code></pre>"},{"location":"MINIFY_DESIGN/#2-assignment-targets","title":"2. Assignment Targets","text":"<pre><code>// ast::StmtAssign\ntargets: Vec&lt;Expr&gt;  // Can be Name, Tuple, List, Subscript, Attribute\n\n// ast::StmtAnnAssign\ntarget: Expr\n\n// ast::StmtAugAssign\ntarget: Expr\n\n// Extract Name nodes: Expr::Name(ExprName { id, .. }) -&gt; id\n</code></pre>"},{"location":"MINIFY_DESIGN/#3-for-loop-targets","title":"3. For Loop Targets","text":"<pre><code>// ast::StmtFor, ast::StmtAsyncFor\ntarget: Expr  // Can be Name, Tuple, List\n\n// Extract Name nodes recursively from target\n</code></pre>"},{"location":"MINIFY_DESIGN/#4-with-statement-targets","title":"4. With Statement Targets","text":"<pre><code>// ast::StmtWith, ast::StmtAsyncWith\nitems: Vec&lt;WithItem&gt; {\n    context_expr: Expr,\n    optional_vars: Option&lt;Expr&gt;,  // Extract Name from this\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#5-exception-handler-names","title":"5. Exception Handler Names","text":"<pre><code>// ast::ExceptHandler::ExceptHandler\nname: Option&lt;Identifier&gt;  // The 'e' in 'except Error as e'\n</code></pre>"},{"location":"MINIFY_DESIGN/#6-import-aliases","title":"6. Import Aliases","text":"<pre><code>// ast::StmtImport\nnames: Vec&lt;Alias&gt; {\n    name: Identifier,\n    asname: Option&lt;Identifier&gt;,  // Use asname if present, else name\n}\n\n// ast::StmtImportFrom\nnames: Vec&lt;Alias&gt;  // Same structure\n</code></pre>"},{"location":"MINIFY_DESIGN/#name-extraction-algorithm","title":"Name Extraction Algorithm","text":"<pre><code>pub fn extract_names(expr: &amp;Expr) -&gt; Vec&lt;String&gt; {\n    match expr {\n        Expr::Name(ExprName { id, .. }) =&gt; vec![id.to_string()],\n\n        Expr::Tuple(ExprTuple { elts, .. }) |\n        Expr::List(ExprList { elts, .. }) =&gt; {\n            elts.iter()\n                .flat_map(|e| extract_names(e))\n                .collect()\n        }\n\n        // Subscript/Attribute don't bind new names\n        _ =&gt; vec![],\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#exclusion-rules","title":"Exclusion Rules","text":""},{"location":"MINIFY_DESIGN/#exclude-from-renaming","title":"Exclude from renaming:","text":"<ol> <li>Keywords: All 35 Python keywords</li> <li>Builtins: Common builtins (configurable list)</li> <li>Global declarations: Names in <code>global</code> statements</li> <li>Nonlocal declarations: Names in <code>nonlocal</code> statements</li> <li>Class-scoped names: Do not process class bodies</li> <li>Single underscores: <code>_</code> (convention for unused variables)</li> <li>Dunder names: <code>__name__</code>, <code>__init__</code>, etc.</li> </ol>"},{"location":"MINIFY_DESIGN/#detection","title":"Detection:","text":"<pre><code>pub fn should_exclude(name: &amp;str) -&gt; bool {\n    name == \"_\" ||\n    name.starts_with(\"__\") &amp;&amp; name.ends_with(\"__\") ||\n    PYTHON_KEYWORDS.contains(&amp;name)\n}\n\npub fn collect_global_nonlocal(body: &amp;[Stmt]) -&gt; Vec&lt;String&gt; {\n    body.iter()\n        .filter_map(|stmt| match stmt {\n            Stmt::Global(g) =&gt; Some(g.names.iter()),\n            Stmt::Nonlocal(n) =&gt; Some(n.names.iter()),\n            _ =&gt; None,\n        })\n        .flatten()\n        .map(|id| id.to_string())\n        .collect()\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#collection-algorithm","title":"Collection Algorithm","text":"<pre><code>pub fn collect_function_bindings(func: &amp;StmtFunctionDef) -&gt; FunctionPlan {\n    let mut bindings = Vec::new();\n    let mut excluded = Vec::new();\n\n    // 1. Collect global/nonlocal declarations\n    let protected = collect_global_nonlocal(&amp;func.body);\n    excluded.extend(protected.clone());\n\n    // 2. Collect parameters\n    collect_params(&amp;func.parameters, &amp;mut bindings);\n\n    // 3. Traverse body for assignments, loops, withs, excepts, imports\n    collect_from_body(&amp;func.body, &amp;mut bindings, &amp;protected);\n\n    // 4. Remove excluded patterns\n    bindings.retain(|name| !should_exclude(name) &amp;&amp; !protected.contains(name));\n\n    // 5. Sort for stability\n    bindings.sort();\n    bindings.dedup();\n\n    // 6. Generate rename map\n    let mut gen = ShortNameGen::new();\n    let mut rename_map = HashMap::new();\n\n    for name in &amp;bindings {\n        let short = gen.next(&amp;PYTHON_KEYWORDS.iter().map(|s| s.to_string()).collect::&lt;Vec&lt;_&gt;&gt;());\n        rename_map.insert(name.clone(), short);\n    }\n\n    FunctionPlan {\n        name: func.name.to_string(),\n        local_names: bindings,\n        rename_map,\n        excluded_names: excluded,\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#scope-rules","title":"Scope Rules","text":""},{"location":"MINIFY_DESIGN/#include-in-function-scope","title":"Include in function scope:","text":"<ul> <li>Function parameters (all types)</li> <li>Assignment targets (direct names only, not attributes/subscripts)</li> <li>For/AsyncFor targets</li> <li>With/AsyncWith optional_vars</li> <li>ExceptHandler names</li> <li>Import/ImportFrom aliases (the asname or name)</li> </ul>"},{"location":"MINIFY_DESIGN/#exclude-from-function-scope","title":"Exclude from function scope:","text":"<ul> <li>Class definitions (process separately, not recursively)</li> <li>Nested function definitions (process separately)</li> <li>Global/nonlocal declared names</li> <li>Attribute access (obj.attr - only rename obj)</li> <li>Subscript access (obj[key] - only rename obj/key)</li> </ul>"},{"location":"MINIFY_DESIGN/#stable-function-order","title":"Stable Function Order","text":"<p>Collect functions in source order:</p> <pre><code>pub fn collect_functions_stable(module: &amp;ast::Mod) -&gt; Vec&lt;&amp;StmtFunctionDef&gt; {\n    let mut funcs = Vec::new();\n\n    match module {\n        ast::Mod::Module(m) =&gt; visit_stmts_for_functions(&amp;m.body, &amp;mut funcs),\n        ast::Mod::Expression(_) =&gt; {},\n    }\n\n    funcs  // Already in source order\n}\n\nfn visit_stmts_for_functions&lt;'a&gt;(\n    stmts: &amp;'a [Stmt],\n    funcs: &amp;mut Vec&lt;&amp;'a StmtFunctionDef&gt;,\n) {\n    for stmt in stmts {\n        match stmt {\n            Stmt::FunctionDef(f) =&gt; funcs.push(f),\n            Stmt::AsyncFunctionDef(f) =&gt; {\n                // Convert async to sync representation if needed\n            }\n            Stmt::ClassDef(c) =&gt; {\n                // Don't recurse into class bodies\n            }\n            // Don't recurse into nested scopes\n            _ =&gt; {}\n        }\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#serialization-example","title":"Serialization Example","text":"<pre><code>{\n  \"functions\": [\n    {\n      \"name\": \"calculate\",\n      \"local_names\": [\"result\", \"temp\", \"value\"],\n      \"rename_map\": {\n        \"result\": \"a\",\n        \"temp\": \"b\",\n        \"value\": \"c\"\n      },\n      \"excluded_names\": [\"global_config\"]\n    }\n  ],\n  \"python_keywords\": [\"False\", \"None\", \"True\", ...],\n  \"builtins\": [\"print\", \"len\", \"range\", ...]\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#implementation-checklist","title":"Implementation Checklist","text":"<ul> <li>[ ] Define <code>FunctionPlan</code> and <code>MinifyPlan</code> structs with serde</li> <li>[ ] Implement <code>ShortNameGen</code> with tests</li> <li>[ ] Create <code>PYTHON_KEYWORDS</code> constant</li> <li>[ ] Implement <code>extract_names()</code> for recursive name extraction</li> <li>[ ] Implement <code>should_exclude()</code> filter</li> <li>[ ] Implement <code>collect_global_nonlocal()</code></li> <li>[ ] Implement parameter collection</li> <li>[ ] Implement body traversal for all binding forms</li> <li>[ ] Implement stable function ordering</li> <li>[ ] Add comprehensive tests for each AST node type</li> <li>[ ] Verify serialization round-trip</li> </ul>"},{"location":"MINIFY_DESIGN/#edge-cases","title":"Edge Cases","text":"<ol> <li>Tuple unpacking: <code>a, b = foo()</code> - extract both <code>a</code> and <code>b</code></li> <li>Nested unpacking: <code>a, (b, c) = foo()</code> - extract <code>a</code>, <code>b</code>, <code>c</code></li> <li>Walrus operator: <code>:=</code> creates bindings in expressions (handle carefully)</li> <li>List comprehension variables: Lexically scoped, don't leak (skip)</li> <li>Match patterns: Variable bindings in match cases (include)</li> <li>Type parameters (3.12+): Generic type vars (include if present)</li> </ol>"},{"location":"MINIFY_DESIGN/#notes","title":"Notes","text":"<ul> <li>This design focuses on planning only - no AST rewriting</li> <li>Output is JSON-serializable for external tools</li> <li>Function order is deterministic (source position)</li> <li>Name collisions avoided by checking keywords in generator</li> <li>Class scope deliberately excluded (different minification strategy needed)</li> </ul>"},{"location":"MINIFY_DESIGN/#references","title":"References","text":"<ul> <li>pyminifier (liftoffsoftware)</li> <li>TreeShaker (sclabs)</li> <li>\u201cBuild a Python tree-shaker in Rust\u201d (dev.to)</li> <li>\u201cCrude Python tree-shaking for squeezing into AWS Lambda package size limits\u201d (sam152)</li> </ul>"},{"location":"TESTING/","title":"Testing tsrs (Tree-Shaking in Rust for Python)","text":""},{"location":"TESTING/#overview","title":"Overview","text":"<p>The test infrastructure validates that tsrs correctly slims virtual environments without breaking functionality.</p>"},{"location":"TESTING/#test-strategy","title":"Test Strategy","text":"<p>High Precision, Low Recall Philosophy: We validate that after tree-shaking, the application still works perfectly. This ensures we're not removing code that's actually used.</p>"},{"location":"TESTING/#the-test-flow","title":"The Test Flow","text":"<p>For each test repository:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. Create Full venv                \u2502\n\u2502  2. Install all dependencies        \u2502\n\u2502  3. Run functionality tests \u2713        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  4. Run tsrs                        \u2502\n\u2502  5. Create .venv-slim with only     \u2502\n\u2502     the packages that are imported  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  6. Run same tests with .venv-slim  \u2502\n\u2502  7. Verify all tests still pass \u2713   \u2502\n\u2502  8. Report size savings             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"TESTING/#test-repositories","title":"Test Repositories","text":""},{"location":"TESTING/#1-simple-data","title":"1. simple-data","text":"<ul> <li>Dependencies: requests, click, pydantic</li> <li>Purpose: Tests HTTP, CLI, and validation libraries</li> <li>Test: Validates imports and Pydantic model functionality</li> </ul>"},{"location":"TESTING/#2-cli-tool","title":"2. cli-tool","text":"<ul> <li>Dependencies: typer, rich</li> <li>Purpose: Tests CLI framework and output libraries</li> <li>Test: Validates typer and rich functionality</li> </ul>"},{"location":"TESTING/#how-to-add-more-tests","title":"How to Add More Tests","text":"<p>Create a new test repo:</p> <pre><code>mkdir test_repos/my-test\ncd test_repos/my-test\ngit init\n\n# Create pyproject.toml with dependencies\n# Create Python code that uses those dependencies\n# Create test.sh that validates everything works\n# Commit\n\ngit add -A\ngit commit -m \"Initial test repo\"\n</code></pre> <p>The test runner will auto-discover it.</p>"},{"location":"TESTING/#running-tests","title":"Running Tests","text":""},{"location":"TESTING/#prerequisites","title":"Prerequisites","text":"<pre><code># Build the CLI\ncargo build --release --bin tsrs-cli\n\n# Ensure Python 3.7+ is available\npython --version\n</code></pre>"},{"location":"TESTING/#run-all-tests","title":"Run All Tests","text":"<pre><code>cd test_repos\nbash run_tests.sh\n</code></pre>"},{"location":"TESTING/#run-single-test","title":"Run Single Test","text":"<pre><code>cd test_repos/simple-data\npython -m venv .venv\n.venv/bin/pip install -q -e .\n.venv/bin/python test.sh\n\n# Then manually:\n../../target/release/tsrs-cli slim . .venv -o .venv-slim\nVIRTUAL_ENV=.venv-slim .venv-slim/bin/python test.sh\n</code></pre>"},{"location":"TESTING/#what-gets-tested","title":"What Gets Tested","text":"<p>\u2705 Functionality: Application code works identically before/after \u2705 Imports: All imported packages are available \u2705 Size Reduction: Quantifies how much space is saved \u2705 Safety: Validates nothing critical was removed  </p>"},{"location":"TESTING/#success-criteria","title":"Success Criteria","text":"<p>Each test is considered successful if:</p> <ol> <li>\u2705 Original venv tests pass</li> <li>\u2705 tree-shaking completes without error</li> <li>\u2705 Slimmed venv tests pass (same test, slimmer environment)</li> <li>\u2705 Size reduction is meaningful (typically 30-70% smaller)</li> </ol>"},{"location":"TESTING/#expected-results","title":"Expected Results","text":"<p>When you run the test suite, you should see:</p> <pre><code>==================================================\ntsrs Test Runner\n==================================================\n\n==================================================\nTesting: simple-data\n==================================================\n[1/5] Creating virtual environment...\n[2/5] Installing dependencies...\n[3/5] Running test (before slimming)...\n\u2713 Before test passed\n[4/5] Running tree-shaking...\n\u2713 Tree-shaking completed\n[5/5] Running test (after slimming)...\n\u2713 After test passed\n\nSize comparison:\n  Original: 145M\n  Slimmed:  65M\n\n==================================================\nTesting: cli-tool\n==================================================\n[1/5] Creating virtual environment...\n[2/5] Installing dependencies...\n[3/5] Running test (before slimming)...\n\u2713 Before test passed\n[4/5] Running tree-shaking...\n\u2713 Tree-shaking completed\n[5/5] Running test (after slimming)...\n\u2713 After test passed\n\nSize comparison:\n  Original: 120M\n  Slimmed:  52M\n\n==================================================\nSummary\n==================================================\nPassed: 2\nFailed: 0\n==================================================\n\u2713 All tests passed!\n</code></pre>"},{"location":"TESTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"TESTING/#test-fails-with-testsh-not-found","title":"Test fails with \"test.sh not found\"","text":"<p>Make sure your test repo has an executable <code>test.sh</code> file.</p>"},{"location":"TESTING/#original-venv-test-fails","title":"Original venv test fails","text":"<p>Install dependencies with: <code>.venv/bin/pip install -e .</code></p>"},{"location":"TESTING/#slimmed-venv-test-fails","title":"Slimmed venv test fails","text":"<p>This indicates tsrs removed a package that's actually needed. This is the high-precision validation working - it caught a false positive.</p>"},{"location":"TESTING/#check-what-was-removed","title":"Check what was removed","text":"<pre><code>ls .venv/lib/python*/site-packages\nls .venv-slim/lib/python*/site-packages\n# Compare the two\n</code></pre>"},{"location":"TESTING/#philosophy","title":"Philosophy","text":"<p>Better to keep unused code than break working code.</p> <p>The test suite proves this philosophy works in practice: - We leave room for indirect usage patterns - We preserve all public APIs - We validate that real applications work after slimming - We prioritize correctness over aggressive optimization</p>"},{"location":"TEST_REPOS_SUMMARY/","title":"Test Repositories Summary","text":""},{"location":"TEST_REPOS_SUMMARY/#overview","title":"Overview","text":"<p>The <code>test_repos</code> directory contains 5 diverse Python projects that validate tsrs works correctly across classic Python libraries and use cases.</p>"},{"location":"TEST_REPOS_SUMMARY/#the-5-test-repos","title":"The 5 Test Repos","text":""},{"location":"TEST_REPOS_SUMMARY/#1-simple-data","title":"1. simple-data","text":"<p>Purpose: HTTP requests, CLI interfaces, and data validation Dependencies: requests, click, pydantic What it tests: - HTTP library imports - CLI framework (Click) - Pydantic model validation - Data model instantiation</p> <p>Expected size reduction: 30-40%</p>"},{"location":"TEST_REPOS_SUMMARY/#2-cli-tool","title":"2. cli-tool","text":"<p>Purpose: CLI application framework and formatted output Dependencies: typer, rich What it tests: - Typer decorators and command routing - Rich table rendering - Rich console styling - CLI argument parsing</p> <p>Expected size reduction: 25-35%</p>"},{"location":"TEST_REPOS_SUMMARY/#3-pandas-analysis-new","title":"3. pandas-analysis \u2728 NEW","text":"<p>Purpose: Data analysis and scientific computing Dependencies: pandas, numpy What it tests: - Pandas DataFrame operations - NumPy array operations - DataFrame aggregation (groupby) - Statistical calculations (mean, std, min, max)</p> <p>Expected size reduction: 40-50%</p> <p>Classic Python library for data science - one of the largest packages</p>"},{"location":"TEST_REPOS_SUMMARY/#4-ml-classifier-new","title":"4. ml-classifier \u2728 NEW","text":"<p>Purpose: Machine learning model training and evaluation Dependencies: scikit-learn, numpy What it tests: - Dataset generation - Model training (Random Forest) - Cross-validation and train/test split - Performance metrics (accuracy, precision, recall) - Tree-based ensemble methods</p> <p>Expected size reduction: 45-55%</p> <p>Tests the complex scikit-learn ecosystem with lots of submodules</p>"},{"location":"TEST_REPOS_SUMMARY/#5-data-viz-new","title":"5. data-viz \u2728 NEW","text":"<p>Purpose: Data visualization and plotting Dependencies: matplotlib, seaborn, pandas What it tests: - Matplotlib figure creation and plotting - Matplotlib pyplot interface - Seaborn statistical plotting - Multiple plot types (line, scatter, histogram) - Color mapping and legend handling</p> <p>Expected size reduction: 35-45%</p> <p>Tests visualization libraries with heavy dependencies</p>"},{"location":"TEST_REPOS_SUMMARY/#why-these-5-repos","title":"Why These 5 Repos?","text":"<p>These repos represent classic Python ecosystem projects:</p> Domain Library Repo Data Science pandas, numpy, matplotlib, seaborn pandas-analysis, data-viz Machine Learning scikit-learn ml-classifier Web/HTTP requests, fastapi simple-data, web-api CLI Tools click, typer, rich simple-data, cli-tool Validation pydantic simple-data, web-api <p>Together they cover: - \u2705 The full PyData ecosystem - \u2705 Complex dependency trees (pandas, sklearn have 20+ sub-dependencies) - \u2705 Different package types (frameworks, libraries, utilities) - \u2705 Real-world usage patterns - \u2705 Significant size reduction opportunities</p>"},{"location":"TEST_REPOS_SUMMARY/#running-the-tests","title":"Running the Tests","text":""},{"location":"TEST_REPOS_SUMMARY/#quick-start","title":"Quick Start","text":"<pre><code># Build tsrs\ncargo build --release --bin tsrs-cli\n\n# Run all 5 tests\ncd test_repos\nbash run_tests.sh\n</code></pre>"},{"location":"TEST_REPOS_SUMMARY/#expected-output","title":"Expected Output","text":"<pre><code>==================================================\nTesting: simple-data\n==================================================\n[1/5] Creating virtual environment...\n[2/5] Installing dependencies...\n[3/5] Running test (before slimming)...\n\u2713 Before test passed\n[4/5] Running tree-shaking...\n\u2713 Tree-shaking completed\n[5/5] Running test (after slimming)...\n\u2713 After test passed\n\nSize comparison:\n  Original: 145M\n  Slimmed:  95M\n\n==================================================\nTesting: cli-tool\n==================================================\n... (similar for each repo)\n\n==================================================\nSummary\n==================================================\nPassed: 5\nFailed: 0\n==================================================\n\u2713 All tests passed!\n</code></pre>"},{"location":"TEST_REPOS_SUMMARY/#what-gets-validated","title":"What Gets Validated","text":"<p>For each test repo, the test suite validates:</p> <ol> <li>Original venv works \u2713</li> <li>All dependencies install correctly</li> <li>Imports work</li> <li> <p>Functionality passes tests</p> </li> <li> <p>Tree-shaking completes \u2713</p> </li> <li>tsrs analyzes the code</li> <li>Creates <code>.venv-slim</code> with only used packages</li> <li> <p>No errors during slimming</p> </li> <li> <p>Slimmed venv still works \u2713</p> </li> <li>Same test.sh passes with slim venv</li> <li>All imported packages are available</li> <li>Functionality unchanged</li> <li> <p>This is the critical validation</p> </li> <li> <p>Size reduction is real \u2713</p> </li> <li>Shows before/after sizes</li> <li>Typically 30-55% reduction</li> </ol>"},{"location":"TEST_REPOS_SUMMARY/#success-criteria","title":"Success Criteria","text":"<p>All tests pass if: - \u2705 Original venv tests pass - \u2705 Tree-shaking completes without error - \u2705 Slimmed venv tests pass - \u2705 Size reduction is 25%+ (validated)</p>"},{"location":"TEST_REPOS_SUMMARY/#why-this-approach-works","title":"Why This Approach Works","text":"<p>High Precision Testing: By running the same test suite before and after slimming, we prove that: 1. We didn't remove anything the code actually uses 2. The slimmed venv is fully functional 3. Size savings are real and validated</p> <p>Representative Coverage: These 5 repos use: - 10+ major Python packages - 50+ sub-dependencies - Different import patterns - Different coding styles</p> <p>Safe by Design: If tree-shaking works correctly on these diverse repos, it will work on most Python projects.</p>"},{"location":"TEST_REPOS_SUMMARY/#adding-more-test-repos","title":"Adding More Test Repos","text":"<p>To add a new test repo:</p> <pre><code>mkdir test_repos/my-repo\ncd test_repos/my-repo\ngit init\n\n# Create:\n# - pyproject.toml (with dependencies)\n# - Python files (your application)\n# - test.sh (validation script)\n\ngit add -A\ngit commit -m \"Initial test repo\"\n</code></pre> <p>The test runner will auto-discover it on next run.</p>"},{"location":"TEST_REPOS_SUMMARY/#files-structure","title":"Files Structure","text":"<pre><code>test_repos/\n\u251c\u2500\u2500 simple-data/              # Simple data processing\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 cli-tool/                 # CLI application\n\u2502   \u251c\u2500\u2500 app.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 pandas-analysis/          # Data analysis \u2728 NEW\n\u2502   \u251c\u2500\u2500 analysis.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 ml-classifier/            # ML training \u2728 NEW\n\u2502   \u251c\u2500\u2500 classifier.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 data-viz/                 # Visualization \u2728 NEW\n\u2502   \u251c\u2500\u2500 visualizer.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 run_tests.sh              # Master test runner\n\u2514\u2500\u2500 README.md                 # Documentation\n</code></pre>"},{"location":"TEST_REPOS_SUMMARY/#reference","title":"Reference","text":"<p>See <code>TESTING.md</code> in the root for comprehensive testing documentation. See <code>test_repos/README.md</code> for detailed test repo information.</p>"}]}