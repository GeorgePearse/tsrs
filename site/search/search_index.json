{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tsrs - Tree-Shaking in Rust for Python","text":"<p>A high-performance tree-shaking implementation in Rust for Python modules and packages.</p>"},{"location":"#manifesto","title":"Manifesto","text":"<p>\"Ever had someone say, 'just copy the function, we don't need the whole package'? What if that didn't have to be true?\"</p> <p>Tree-shaking enables developers to depend on large, well-designed libraries while only deploying the code they actually use. No more choosing between monolithic packages or duplicating code. Get the best of both worlds: leverage battle-tested libraries while keeping your deployments lean and efficient.</p>"},{"location":"#overview","title":"Overview","text":"<p>Tree-shaking is the process of analyzing code to identify and remove unused exports from Python modules. This project provides a Rust-based implementation that can be used from Python to detect dead code and optimize module sizes.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#cli","title":"CLI","text":"<pre><code># Analyze a virtual environment\n./target/debug/tsrs-cli analyze /path/to/venv\n\n# Create a slim venv from Python code and venv\n./target/debug/tsrs-cli slim &lt;python-directory&gt; &lt;venv-location&gt;\n\n# Create slim venv with custom output path\n./target/debug/tsrs-cli slim &lt;python-directory&gt; &lt;venv-location&gt; -o /path/to/output/.venv-slim\n</code></pre>"},{"location":"#minify-plan-preview","title":"Minify Plan Preview","text":"<pre><code># Inspect planned local renames without rewriting code\n./target/debug/tsrs-cli minify-plan path/to/module.py\n\n# Apply a curated plan to a file (prints to stdout by default)\n./target/debug/tsrs-cli apply-plan path/to/module.py --plan plan.json\n\n# Apply in place with a backup and stats\n./target/debug/tsrs-cli apply-plan path/to/module.py --plan plan.json --in-place --backup-ext .bak --stats --json\n</code></pre>"},{"location":"#safe-local-rename-rewrite","title":"Safe Local Rename Rewrite","text":"<pre><code># Emit rewritten source when safe (no nested scopes/imports)\n./target/debug/tsrs-cli minify path/to/module.py\n\n# Rewrite in place (updates the file on disk)\n./target/debug/tsrs-cli minify path/to/module.py --in-place\n\n# Keep a .bak backup before rewriting in place\n./target/debug/tsrs-cli minify path/to/module.py --in-place --backup-ext .bak\n\n# Inspect rename counts (optionally emit JSON)\n./target/debug/tsrs-cli minify path/to/module.py --stats\n./target/debug/tsrs-cli minify path/to/module.py --stats --json\n</code></pre>"},{"location":"#directory-rewrite","title":"Directory Rewrite","text":"<pre><code># Mirror ./src into ./src-min with minified modules\n./target/debug/tsrs-cli minify-dir ./src\n\n# Write into a custom output directory\n./target/debug/tsrs-cli minify-dir ./src --out-dir ./dist/min\n\n# Only minify application code, skip tests\n./target/debug/tsrs-cli minify-dir ./project \\\n  --include \"project/**\" \\\n  --exclude \"project/tests/**\"\n\n# Preview changes without writing files\n./target/debug/tsrs-cli minify-dir ./src --dry-run\n\n# Rewrite files in place (no mirror directory)\n./target/debug/tsrs-cli minify-dir ./src --in-place\n\n# Rewrite in place and keep .bak backups of originals\n./target/debug/tsrs-cli minify-dir ./src --in-place --backup-ext .bak\n</code></pre> <p>Each run prints per-file status lines (minified, skipped, bailouts) and summarises the total work. Bailouts copy the original file verbatim so you never lose working code\u2014re-run with <code>--debug</code> to inspect why a file could not be safely renamed.</p> <p>Add <code>--stats</code> to include per-file rename counts in the output, and combine it with <code>--json</code> for a machine-readable summary of the same data.</p>"},{"location":"#plan-bundles","title":"Plan Bundles","text":"<pre><code># Create a directory-wide plan bundle\n./target/debug/tsrs-cli minify-plan-dir ./src --out plan.json\n\n# Apply the bundle to a mirrored output tree\n./target/debug/tsrs-cli apply-plan-dir ./src --plan plan.json --out-dir ./src-min\n\n# Apply in place with backups and detailed stats\n./target/debug/tsrs-cli apply-plan-dir ./src --plan plan.json --in-place --backup-ext .bak --stats --json\n\n# CI: fail if a rewrite would change files or introduce bailouts\n./target/debug/tsrs-cli minify-dir ./src --dry-run --fail-on-change --fail-on-bailout\n</code></pre>"},{"location":"#references","title":"References","text":"<ul> <li>pyminifier (liftoffsoftware)</li> <li>TreeShaker (sclabs)</li> <li>\u201cBuild a Python tree-shaker in Rust\u201d (dev.to)</li> <li>\u201cCrude Python tree-shaking for squeezing into AWS Lambda package size limits\u201d (sam152)</li> </ul>"},{"location":"#how-it-works","title":"How it Works","text":"<ol> <li>Scans the Python code directory for all import statements</li> <li>Analyzes the source venv to discover all installed packages</li> <li>Maps imports to packages and copies only the used packages to a new slim venv</li> <li>Creates <code>.venv-slim</code> with only the minimal dependencies needed</li> </ol>"},{"location":"#example","title":"Example","text":"<pre><code># Slim your venv based on actual code usage\ntsrs-cli slim ./src ./.venv\n# Creates: ./.venv-slim with only the packages your code imports\n</code></pre>"},{"location":"#building","title":"Building","text":""},{"location":"#cli-only","title":"CLI Only","text":"<pre><code>cargo build --release --bin tsrs-cli\n./target/release/tsrs-cli --help\n</code></pre>"},{"location":"#with-python-extension","title":"With Python Extension","text":"<p>This project can also build as a Python extension module using PyO3.</p> <pre><code># Setup (optional Python feature)\npip install maturin\n\n# Build and develop\nmaturin develop\n\n# Or build a wheel\nmaturin build --release\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#core-modules","title":"Core Modules","text":"<ul> <li><code>venv</code> - Virtual environment discovery and package analysis</li> <li><code>imports</code> - Import statement extraction and tracking</li> <li><code>callgraph</code> - Function call graph analysis per package</li> <li>Tracks which functions are defined in each package</li> <li>Maps external dependencies between packages</li> <li>Identifies unused/dead code that is never called</li> <li><code>slim</code> - Creates minimal venvs based on code analysis</li> </ul>"},{"location":"#how-tree-shaking-works","title":"How Tree-Shaking Works","text":"<p>The tool builds a complete picture of your code's dependencies:</p> <ol> <li>Import Analysis: Extracts all <code>import</code> and <code>from...import</code> statements from your code</li> <li>Call Graph Building: Analyzes function definitions and calls in your Python code</li> <li>Package Mapping: Maps imports to actual packages in your venv</li> <li>Dead Code Detection: Identifies functions/classes that are defined but never used</li> <li>Dependency Reduction: Creates a slim venv with only the necessary packages</li> </ol> <p>This multi-layered approach ensures you don't accidentally remove code that's used through indirect calls or dynamic imports.</p>"},{"location":"#high-precision-low-recall-philosophy","title":"High Precision, Low Recall Philosophy","text":"<p>tsrs prioritizes precision over recall in dead code detection:</p> <ul> <li>High Precision: When we flag something as dead/unused, it almost certainly is</li> <li>Low Recall: We're happy to miss dead code - better conservative than aggressive</li> </ul> <p>We will keep:</p> <ul> <li>All global variables and module-level constants in any package (these may be used externally or through reflection)</li> <li>All public API surfaces even if not directly called in your code</li> <li>Packages you explicitly import, even if only specific functions are used</li> <li>Any code that could potentially be used (even indirectly)</li> </ul> <p>The philosophy: It's better to leave in unused code than to accidentally break something that's actually used through indirect calls, dynamic imports, reflection, or a library's public API.</p> <p>We're optimizing for correctness over comprehensiveness - we'd rather miss some dead code than introduce false positives that break your application.</p>"},{"location":"#development","title":"Development","text":"<pre><code>cargo test\ncargo fmt\ncargo clippy\n</code></pre>"},{"location":"#references-inspiration","title":"References &amp; Inspiration","text":""},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>Ruff - An extremely fast Python linter written in Rust. Uses <code>ruff_python_parser</code> for parsing Python code.</li> <li>Pylyzer - A fast, feature-rich static code analyzer &amp; language server for Python. Uses Rust internally with type checking capabilities.</li> <li>Skylos - A static analysis tool for Python codebases that detects dead code, unused functions, classes, imports, and variables. Also includes security flaw detection.</li> </ul>"},{"location":"#discussion","title":"Discussion","text":"<ul> <li>Reddit Discussion: Is there any support in Python for something like tree-shaking?</li> </ul>"},{"location":"#license","title":"License","text":"<p>TBD</p>"},{"location":"AGENTS/","title":"AGENTS.md","text":"<p>Purpose: This file provides comprehensive guidance to Claude Code and AI agents when working on code improvements in the tsrs repository. It includes architectural details, known limitations, test coverage maps, and patterns to follow.</p>"},{"location":"AGENTS/#quick-links","title":"Quick Links","text":"<ul> <li>Project Overview: See section \"Project Overview\" below</li> <li>Architecture: See \"Code Architecture &amp; Module Responsibilities\"</li> <li>Testing: See \"Testing Strategy &amp; Coverage Map\"</li> <li>Making Changes: See \"Development Workflow\" and \"Common Patterns\"</li> <li>Known Issues: See \"Current State &amp; Known Limitations\"</li> </ul>"},{"location":"AGENTS/#project-overview","title":"Project Overview","text":"<p>tsrs (Tree-Shaking in Rust for Python) is a high-performance Rust implementation that analyzes Python code to identify and remove unused exports from modules and packages. It can create minimal virtual environments based on actual code usage, optimizing deployment sizes (typically 30-70% reduction).</p>"},{"location":"AGENTS/#current-version","title":"Current Version","text":"<ul> <li>Cargo Version: 0.2.0</li> <li>Edition: 2021</li> <li>Python Support: 3.7+</li> <li>Latest Release: 2025-11-01</li> </ul>"},{"location":"AGENTS/#core-philosophy","title":"Core Philosophy","text":"<p>The project prioritizes high precision over aggressive optimization: - Never remove code unless absolutely certain it's unused - Keep module-level exports and public APIs to avoid breaking indirect usage patterns - Conservative with dynamic features and reflection - Correctness over comprehensiveness</p>"},{"location":"AGENTS/#code-architecture-module-responsibilities","title":"Code Architecture &amp; Module Responsibilities","text":""},{"location":"AGENTS/#file-to-responsibility-map","title":"File-to-Responsibility Map","text":"File Primary Responsibility Key Types Dependencies <code>src/lib.rs</code> Library root, public API, PyO3 extension <code>MinifyPlan</code>, <code>FunctionPlan</code> All modules <code>src/bin/cli.rs</code> CLI argument parsing and command dispatch <code>Cli</code>, <code>Commands</code> enum All core modules <code>src/venv.rs</code> Virtual env discovery, package metadata <code>VenvAnalyzer</code>, <code>PackageInfo</code> walkdir, serde <code>src/imports.rs</code> Extract import statements from AST <code>ImportCollector</code>, <code>Import</code> struct rustpython-parser <code>src/callgraph.rs</code> Build function call graphs, detect dead code <code>CallGraphAnalyzer</code>, <code>CallGraph</code> rustpython-parser, HashMap <code>src/slim.rs</code> Create minimal venvs from imports <code>VenvSlimmer</code> venv, imports, walkdir <code>src/minify.rs</code> Local variable renaming, plan generation <code>Minifier</code>, <code>ShortNameGen</code>, <code>MinifyPlan</code> rustpython-parser, regex <code>src/error.rs</code> Custom error types <code>TsrsError</code> enum thiserror"},{"location":"AGENTS/#data-flow-pipeline","title":"Data Flow Pipeline","text":"<pre><code>Source Code\n    \u2193\n[ImportCollector] \u2192 Extract all import/from-import statements\n    \u2193\n[VenvAnalyzer] \u2192 Map imports to actual packages in venv\n    \u2193\n\u251c\u2500\u2192 [VenvSlimmer] \u2192 Copy only necessary packages to .venv-slim\n\u2514\u2500\u2192 [CallGraphAnalyzer] \u2192 Build function call graph\n         \u2193\n    [Minifier] \u2192 Generate rename plans for local variables\n         \u2193\n    [Plan Writer] \u2192 Serialize MinifyPlan to JSON\n         \u2193\n    [Plan Applier] \u2192 Rewrite source code with minified names\n</code></pre>"},{"location":"AGENTS/#core-data-structures","title":"Core Data Structures","text":"<p>MinifyPlan (serializable, v1 format): <pre><code>{\n  \"format_version\": \"1\",\n  \"python_version\": \"3.7+\",\n  \"functions\": [\n    {\n      \"name\": \"func_name\",\n      \"lineno\": 10,\n      \"local_names\": [\"var1\", \"var2\", ...],\n      \"rename_map\": {\"var1\": \"a\", \"var2\": \"b\", ...},\n      \"excluded_names\": [\"global_x\", \"nonlocal_y\", ...]\n    }\n  ],\n  \"python_keywords\": [...],\n  \"builtins\": [...]\n}\n</code></pre></p> <p>FunctionPlan: - <code>name</code>: Function identifier for debugging - <code>local_names</code>: All names bound in function scope (sorted for stability) - <code>rename_map</code>: Original name \u2192 minified name (a, b, c, ..., z, aa, ab, ..., zz, aaa, ...) - <code>excluded_names</code>: Names that cannot be renamed (globals, nonlocals, builtins, keywords)</p>"},{"location":"AGENTS/#dependencies-overview","title":"Dependencies Overview","text":""},{"location":"AGENTS/#production-dependencies","title":"Production Dependencies","text":"Crate Version Purpose Notes <code>rustpython-parser</code> 0.3 Python AST parsing Fast, handles modern syntax <code>walkdir</code> 2 Directory traversal Used by venv, slim, minify-dir <code>serde</code> + <code>serde_json</code> 1 Serialization For plan format and CLI output <code>anyhow</code> 1 Error context General error handling <code>thiserror</code> 1 Error definitions Custom TsrsError enum <code>clap</code> 4 CLI parsing Derives, matches our command structure <code>regex</code> 1 Pattern matching Import analysis, name validation <code>rayon</code> 1 Parallelization <code>--jobs N</code> support in minify-dir <code>num_cpus</code> 1 CPU detection Default parallelization level <code>encoding_rs</code> 0.8 Charset detection Preserve file encodings <code>similar</code> 2 Diff generation <code>--diff</code> output <code>ignore</code> 0.4 <code>.gitignore</code> support <code>--respect-gitignore</code> flag <code>dunce</code> 1 Path normalization Windows/POSIX compatibility <code>tracing</code> + <code>tracing-subscriber</code> 0.1 / 0.3 Structured logging Debug logging via <code>RUST_LOG</code>"},{"location":"AGENTS/#optional-features","title":"Optional Features","text":"<ul> <li><code>python-extension</code>: Enables PyO3 extension (requires pyo3 0.22)</li> <li>Default: No features enabled</li> </ul>"},{"location":"AGENTS/#dev-dependencies","title":"Dev Dependencies","text":"<ul> <li><code>assert_cmd</code> (2): CLI testing</li> <li><code>tempfile</code> (3): Temporary directories for tests</li> <li><code>serde_json</code> (1): JSON manipulation in tests</li> </ul>"},{"location":"AGENTS/#current-state-known-limitations","title":"Current State &amp; Known Limitations","text":""},{"location":"AGENTS/#what-works-well","title":"What Works Well \u2705","text":"<ol> <li>Basic minification: Simple functions with parameters, locals, assignments</li> <li>Import analysis: Accurately extracts import statements (including from/import, aliases)</li> <li>Package mapping: Correctly maps imports to venv packages</li> <li>Encoding preservation: Maintains UTF-8, BOMs, line endings, trailing newlines</li> <li>Plan stability: Plans are reproducible (sorted, deterministic)</li> <li>Nested function handling: Can minify inside closures and class bodies</li> <li>Parallel processing: Multi-core support via rayon</li> <li>Diff output: Clear <code>--diff</code> with configurable context</li> </ol>"},{"location":"AGENTS/#known-limitations","title":"Known Limitations \u26a0\ufe0f","text":"<ol> <li>Bailout on nested scopes: Functions containing inner functions/classes skip minification</li> <li>Reason: Scope tracking complexity with closures</li> <li>File: <code>src/minify.rs</code> lines ~400-450</li> <li> <p>Example: Function with nested <code>def</code> won't be minified</p> </li> <li> <p>Global/nonlocal declarations: Any function with <code>global x</code> or <code>nonlocal y</code> is skipped</p> </li> <li>Reason: Can't safely rename variables that reference outer scope</li> <li> <p>File: <code>src/minify.rs</code> - <code>GlobalCollector</code> struct</p> </li> <li> <p>No comprehension variable minification: List/dict/set comprehensions preserve variable names</p> </li> <li>Reason: Complex scope rules, variables leak in Python 2 style</li> <li> <p>File: <code>src/minify.rs</code> - <code>is_comprehension</code> check</p> </li> <li> <p>Dynamic imports not tracked: <code>importlib.import_module()</code> or string-based imports ignored</p> </li> <li>Reason: Requires dataflow analysis</li> <li> <p>File: <code>src/imports.rs</code> - only handles static import statements</p> </li> <li> <p>Call graph is per-package, not cross-package: Dead code detection doesn't follow imports</p> </li> <li>Reason: Would require whole-program analysis</li> <li> <p>File: <code>src/callgraph.rs</code> - <code>CallGraphAnalyzer</code> builds per-package graphs</p> </li> <li> <p>Class/dunder names not minified: <code>__init__</code>, <code>_private</code>, class-scoped names excluded</p> </li> <li>Reason: Preserve reflection/introspection compatibility</li> <li>File: <code>src/minify.rs</code> - exclusion lists</li> </ol>"},{"location":"AGENTS/#edge-cases-being-handled","title":"Edge Cases Being Handled \u2705","text":"<ol> <li>Multiline strings &amp; docstrings: Stripped during minification (preserves other literals)</li> <li>Decorators with side effects: Preserved (conservative approach)</li> <li>Walrus operator (<code>:=</code>): Handled in assignment collection</li> <li>Match statements (Python 3.10+): Entire function bails out if match found</li> <li>Async functions: Minified same as regular functions</li> <li>With/except variable binding: Captured in assignment targets</li> <li>For-loop variables: Tracked as local bindings</li> </ol>"},{"location":"AGENTS/#missingincomplete-features","title":"Missing/Incomplete Features \u26a0\ufe0f","text":"<ol> <li>Call graph analysis:</li> <li>No interprocedural analysis (function A calls function B not tracked)</li> <li>No type inference for dead code detection</li> <li> <p>Task: Consider SSA form or simpler PDG approach</p> </li> <li> <p>Import analysis:</p> </li> <li>Relative imports within packages not fully resolved</li> <li>No <code>__all__</code> export list analysis</li> <li> <p>Task: Integrate <code>__all__</code> detection</p> </li> <li> <p>Python 3.12+ support:</p> </li> <li>No testing against Python 3.12 type hints (PEP 695)</li> <li>No support for type parameter syntax</li> <li> <p>Task: Update rustpython-parser version + add tests</p> </li> <li> <p>Multi-version handling:</p> </li> <li>Single minify plan per file (can't generate version-specific plans)</li> <li>Task: Add plan versioning for different Python versions</li> </ol>"},{"location":"AGENTS/#testing-strategy-coverage-map","title":"Testing Strategy &amp; Coverage Map","text":""},{"location":"AGENTS/#unit-test-coverage-34-tests-passing","title":"Unit Test Coverage (34 tests passing)","text":"<p>imports.rs (3 tests): - \u2705 Skips relative imports - \u2705 Collects top-level modules - \u2705 Ignores duplicates and handles aliases</p> <p>minify.rs - Planning (8 tests): - \u2705 Records globals and nonlocals correctly - \u2705 Plans comprehension detection (sets bailout flag) - \u2705 Collects parameters and locals - \u2705 Preserves closure variables - \u2705 Handles from-import aliases</p> <p>minify.rs - Rewriting (19 tests): - \u2705 Simple plan application - \u2705 Import alias handling (multiple variants) - \u2705 Comprehension bailout behavior - \u2705 Dotted import handling (skips without alias) - \u2705 Star import behavior (skipped) - \u2705 Name replacement stability - \u2705 Docstring stripping (module, function, async, class, nested) - \u2705 Decorator preservation - \u2705 Multiline docstring preservation - \u2705 Global/nonlocal respect - \u2705 Match statement bailout - \u2705 Nested function bailout - \u2705 Annotation preservation (not renamed)</p> <p>Gap Analysis - What Needs Testing: - \u274c Call graph dead code detection (no unit tests) - \u274c Venv analysis edge cases (mixed packages, namespaces) - \u274c Large directory traversal (performance tests) - \u274c Error recovery paths - \u26a0\ufe0f Plan format versioning (only v1 tested)</p>"},{"location":"AGENTS/#integration-test-packages","title":"Integration Test Packages","text":"<p>test_unused_function/package_one (2 tests): <pre><code>\u251c\u2500\u2500 test_add_one_and_one \u2705\n\u2514\u2500\u2500 test_hello_world_greet \u2705\n</code></pre> Status: Both pass with full venv and .venv-slim</p> <p>test_slim_packages/ (16 manual test scenarios): <pre><code>\u251c\u2500\u2500 project/ \u2192 Basic import pattern\n\u251c\u2500\u2500 project_alias_function/ \u2192 Function aliases\n\u251c\u2500\u2500 project_alias_import/ \u2192 Module aliases\n\u251c\u2500\u2500 project_backslash_import/ \u2192 Line continuation\n\u251c\u2500\u2500 project_from_import/ \u2192 from X import Y\n\u251c\u2500\u2500 project_function_scope_import/ \u2192 Imports in functions\n\u251c\u2500\u2500 project_if_block_import/ \u2192 Conditional imports\n\u251c\u2500\u2500 project_multi_import/ \u2192 Multiple imports per line\n\u251c\u2500\u2500 project_multiline_import/ \u2192 Parenthesized imports\n\u251c\u2500\u2500 project_submodule_alias/ \u2192 Submodule with alias\n\u251c\u2500\u2500 project_submodule_alias_item/ \u2192 Import specific submodule item\n\u251c\u2500\u2500 project_submodule_import/ \u2192 Direct submodule import\n\u251c\u2500\u2500 project_submodule_wildcard/ \u2192 from X import *\n\u251c\u2500\u2500 project_try_except_import/ \u2192 Try/except imports\n\u251c\u2500\u2500 project_wildcard_import/ \u2192 Wildcard imports\n\u2514\u2500\u2500 unused_pkg/ + used_pkg/ \u2192 Dependency packages\n</code></pre></p> <p>How to Run: <pre><code># Unit tests\ncargo test\n\n# Integration tests (manually)\ncd test_packages/test_unused_function/package_one\nuv sync --all-extras &amp;&amp; uv run pytest -v\n\n# Manual slim verification (example)\ncd test_packages/test_slim_packages/project\npython -m venv .venv\n.venv/bin/pip install -e .\n.venv/bin/python main.py  # Baseline\n../../../../../../target/release/tsrs-cli slim . .venv-slim\nVIRTUAL_ENV=.venv-slim .venv-slim/bin/python main.py  # Slimmed\n</code></pre></p>"},{"location":"AGENTS/#what-tests-are-missing","title":"What Tests Are Missing","text":"<ol> <li>Parallel processing edge cases: Race conditions in rayon traversal</li> <li>File encoding edge cases: UTF-16, Latin-1, mixed encodings</li> <li>Large codebases: Performance testing on 10K+ file projects</li> <li>Plan application with errors: Corrupted plans, missing files</li> <li>Circular imports: Package import cycles</li> <li>Dynamic <code>__all__</code> modification: Runtime export list changes</li> </ol>"},{"location":"AGENTS/#common-patterns-code-style","title":"Common Patterns &amp; Code Style","text":""},{"location":"AGENTS/#rust-code-patterns","title":"Rust Code Patterns","text":"<ol> <li> <p>Error handling: Use <code>Result&lt;T&gt;</code> with <code>?</code> operator + <code>thiserror</code> for custom errors    <pre><code>fn analyze_imports(path: &amp;Path) -&gt; Result&lt;Vec&lt;Import&gt;&gt; {\n    let content = std::fs::read_to_string(path)?;\n    // ...\n    Ok(imports)\n}\n</code></pre></p> </li> <li> <p>AST traversal: <code>rustpython-parser</code> uses recursive visitor pattern    <pre><code>for stmt in &amp;mod_ast.body {\n    match stmt {\n        StmtKind::Import { names, .. } =&gt; { /* handle */ },\n        StmtKind::ImportFrom { module, names, .. } =&gt; { /* handle */ },\n        _ =&gt; {}\n    }\n}\n</code></pre></p> </li> <li> <p>Collection stability: Always sort results before serialization    <pre><code>let mut names = vec![...];\nnames.sort();  // Ensures reproducible plans\n</code></pre></p> </li> <li> <p>Logging: Use <code>tracing::debug!</code>, <code>tracing::info!</code> (configurable via <code>RUST_LOG</code>)    <pre><code>debug!(\"Processing file: {:?}\", path);\n</code></pre></p> </li> <li> <p>Parallel processing: Use rayon for directory operations    <pre><code>files.par_iter().map(|f| minify_file(f)).collect()\n</code></pre></p> </li> </ol>"},{"location":"AGENTS/#python-ast-handling","title":"Python AST Handling","text":"<p>Supported Import Patterns (from <code>src/imports.rs</code>): - \u2705 <code>import module</code> - \u2705 <code>import module as alias</code> - \u2705 <code>import m1, m2, m3</code> - \u2705 <code>from module import name</code> - \u2705 <code>from module import name as alias</code> - \u2705 <code>from module import name1, name2</code> - \u2705 <code>from module import *</code> - \u2705 <code>from . import relative</code> (skipped, preserved) - \u2705 <code>from .. import relative</code> (skipped, preserved)</p> <p>Unsupported: - \u274c <code>importlib.import_module(\"name\")</code> (dynamic) - \u274c <code>__import__(\"name\")</code> (dynamic) - \u274c Late <code>__all__</code> definitions: <code>__all__ = ['a', 'b'] + other_list</code></p>"},{"location":"AGENTS/#minification-scope-rules","title":"Minification Scope Rules","text":"<p>Renamed (function-local only): - Function parameters: <code>def f(x, y, *args, **kwargs)</code> - Assignment targets: <code>x = 1</code> - Loop variables: <code>for x in list:</code> - Exception handlers: <code>except Error as e:</code> - With statement: <code>with open() as f:</code> - Comprehension targets: <code>[x for x in list]</code> (but entire function bails) - Import aliases: <code>from X import Y as name</code> \u2192 <code>name</code> renamed, not <code>Y</code></p> <p>Not Renamed (preserved): - Global names: <code>x</code> with <code>global x</code> in function - Nonlocal names: <code>x</code> with <code>nonlocal x</code> in function - Class scope names: Names defined in <code>class Foo: x = 1</code> - Dunder names: <code>__init__</code>, <code>__call__</code>, <code>__all__</code>, etc. - Single underscore: <code>_</code> - Python keywords: 35 reserved words - Builtin names: <code>print</code>, <code>len</code>, <code>str</code>, <code>dict</code>, etc.</p>"},{"location":"AGENTS/#name-generation-algorithm","title":"Name Generation Algorithm","text":"<p>Sequential generator (stable, deterministic): <pre><code>a, b, c, ..., z,          (1-letter, 26 names)\naa, ab, ac, ..., az, ba, ..., zz,  (2-letter, 676 names)\naaa, aab, ...             (3-letter, 17,576 names)\n</code></pre></p> <p>Never uses: Keywords, builtins, single <code>_</code>, leading <code>__</code></p>"},{"location":"AGENTS/#development-workflow","title":"Development Workflow","text":""},{"location":"AGENTS/#building-running","title":"Building &amp; Running","text":"<pre><code># Debug build\ncargo build\n\n# Release build (optimized)\ncargo build --release\n\n# Build CLI\ncargo build --release --bin tsrs-cli\n./target/release/tsrs-cli --help\n\n# Build Python extension (optional)\npip install maturin\nmaturin develop  # For dev/testing\nmaturin build --release  # For wheel distribution\n</code></pre>"},{"location":"AGENTS/#code-quality-checks","title":"Code Quality Checks","text":"<pre><code># Format\ncargo fmt\n\n# Lint (enforced in pre-commit)\ncargo clippy -- -W clippy::pedantic\n\n# Run all tests\ncargo test\n\n# Run specific test\ncargo test test_name\n\n# Run with output\ncargo test -- --nocapture\n</code></pre>"},{"location":"AGENTS/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>The project enforces: 1. <code>cargo fmt</code> - Code formatting 2. <code>cargo clippy -- -W clippy::pedantic</code> - Linting</p> <p>These must pass before commit or the commit will fail. Run them locally first: <pre><code>cargo fmt &amp;&amp; cargo clippy -- -W clippy::pedantic\n</code></pre></p>"},{"location":"AGENTS/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"AGENTS/#adding-a-new-cli-command","title":"Adding a New CLI Command","text":"<ol> <li> <p>Update clap parsing (<code>src/bin/cli.rs</code>):    <pre><code>#[derive(Subcommand)]\nenum Commands {\n    // ... existing commands ...\n    NewCommand {\n        #[arg(help = \"...\")]\n        path: PathBuf,\n    },\n}\n</code></pre></p> </li> <li> <p>Implement logic in appropriate module:</p> </li> <li>If related to minification: <code>src/minify.rs</code></li> <li>If related to venv: <code>src/venv.rs</code></li> <li> <p>If related to imports: <code>src/imports.rs</code></p> </li> <li> <p>Add tests in <code>tests/</code> or inline <code>#[cfg(test)]</code></p> </li> <li> <p>Update CLI help and README</p> </li> <li> <p>Ensure clippy passes: <code>cargo clippy -- -W clippy::pedantic</code></p> </li> </ol>"},{"location":"AGENTS/#modifying-minification-logic","title":"Modifying Minification Logic","text":"<ol> <li>Review scope rules in MINIFY_DESIGN.md</li> <li>Update exclusion/collection logic in <code>src/minify.rs</code>:</li> <li><code>GlobalCollector</code> for tracking global names</li> <li><code>LocalBindingCollector</code> for function-local names</li> <li><code>NameExcluder</code> for reserved names</li> <li>Add unit tests for new AST node types</li> <li>Test plan stability: Plans should be identical on repeated runs</li> <li>Run <code>cargo test</code> to verify no regressions</li> </ol>"},{"location":"AGENTS/#extending-call-graph-analysis","title":"Extending Call Graph Analysis","text":"<ol> <li>Enhance <code>CallGraphAnalyzer</code> in <code>src/callgraph.rs</code></li> <li>Update tracking for new statement/expression types</li> <li>Document what dead code patterns now detected</li> <li>Test on real packages in <code>test_packages/</code></li> <li>Verify no false positives (conservative is better)</li> </ol>"},{"location":"AGENTS/#debugging-issues","title":"Debugging Issues","text":"<p>Enable debug logging: <pre><code>RUST_LOG=debug cargo run -- &lt;command&gt;\nRUST_LOG=tsrs=trace cargo test -- --nocapture\n</code></pre></p> <p>Inspect minify plans (JSON): <pre><code>./target/release/tsrs-cli minify-plan path/to/file.py | jq\n./target/release/tsrs-cli minify-plan-dir src --out plan.json &amp;&amp; cat plan.json | jq\n</code></pre></p> <p>Generate diffs to see what would change: <pre><code>./target/release/tsrs-cli minify path/to/file.py --diff --diff-context 3\n</code></pre></p> <p>Dry-run without writing: <pre><code>./target/release/tsrs-cli minify-dir ./src --dry-run --stats\n</code></pre></p>"},{"location":"AGENTS/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"AGENTS/#expected-performance","title":"Expected Performance","text":"<ul> <li>Import analysis: ~1-2ms per Python file (linear in file size)</li> <li>Minification planning: ~5-10ms per file (AST walk + name analysis)</li> <li>Minification rewriting: ~2-5ms per file (text replacement)</li> <li>Directory traversal: ~10-100ms for typical project (parallel, configurable threads)</li> </ul>"},{"location":"AGENTS/#bottlenecks-optimization-opportunities","title":"Bottlenecks &amp; Optimization Opportunities","text":"<ol> <li>rustpython-parser parsing: Can be slow on large files (&gt;50KB)</li> <li> <p>Potential: Incremental parsing or caching ASTs</p> </li> <li> <p>String replacement in minify: Linear in file size</p> </li> <li> <p>Potential: Use aho-corasick for multi-pattern matching</p> </li> <li> <p>Directory traversal: Single-threaded by default (walkdir)</p> </li> <li>Current: Parallelized with rayon when using <code>--jobs N</code></li> <li> <p>Status: \u2705 Implemented in v0.2.0</p> </li> <li> <p>Plan serialization: JSON is verbose for large projects</p> </li> <li>Potential: Implement JSONL streaming or binary format</li> </ol>"},{"location":"AGENTS/#profiling","title":"Profiling","text":"<pre><code># Generate flamegraph (install cargo-flamegraph first)\ncargo flamegraph --release -- minify-dir ./target/release /tmp/out\n\n# Profile with perf\ncargo build --release\nperf record -g ./target/release/tsrs-cli minify-dir ./large_project\nperf report\n</code></pre>"},{"location":"AGENTS/#python-compatibility-notes","title":"Python Compatibility Notes","text":""},{"location":"AGENTS/#version-support","title":"Version Support","text":"<ul> <li>Target: Python 3.7+</li> <li>Tested: Python 3.9.2 (test environment)</li> <li>Parsing: rustpython-parser 0.3 (handles up to Python 3.10 syntax)</li> </ul>"},{"location":"AGENTS/#python-syntax-handled","title":"Python Syntax Handled","text":"<p>Python 3.8+: - \u2705 Walrus operator (<code>:=</code> in assignments) - \u2705 Positional-only parameters (<code>/</code> in function defs) - \u2705 f-strings (not minified, preserved as literals)</p> <p>Python 3.10+: - \u2705 Match statements (function bails out if match detected) - \u2705 Union type syntax (<code>X | Y</code> in type hints) - \u274c Type parameter syntax (<code>[T]</code> in class/function defs) - not yet supported</p> <p>Python 3.11+: - \u26a0\ufe0f Exception groups (<code>ExceptionGroup</code>) - preserved - \u26a0\ufe0f Type hints with <code>Never</code> - preserved</p> <p>Python 3.12+ (not officially tested): - \u274c Type parameter syntax (<code>TypeVar</code> in function/class) - \u274c Per-interpreter GIL features - \ud83d\udd04 Task: Update rustpython-parser, add tests</p>"},{"location":"AGENTS/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Line number confusion: AST line numbers are 1-indexed, but string indices are 0-indexed</li> <li> <p>Fix: Account for offset when mapping plan to source</p> </li> <li> <p>UTF-8 vs byte offsets: File may have non-ASCII characters</p> </li> <li>Current: Handled via encoding_rs detection</li> <li> <p>Safe: Preserve encoding throughout pipeline</p> </li> <li> <p>Windows line endings (<code>\\r\\n</code>): May differ from Unix (<code>\\n</code>)</p> </li> <li>Current: Preserved in v0.2.0</li> <li> <p>Safe: Use <code>dunce</code> for path normalization</p> </li> <li> <p>Relative imports in packages: <code>from . import sibling</code> needs careful handling</p> </li> <li>Current: Skipped (conservative)</li> <li>Safe: Keep existing behavior</li> </ol>"},{"location":"AGENTS/#known-bugs-issue-tracker","title":"Known Bugs &amp; Issue Tracker","text":""},{"location":"AGENTS/#recent-issues-020","title":"Recent Issues (0.2.0)","text":"<ol> <li>Encoding preservation: Fixed in v0.2.0</li> <li>What was broken: BOM and encoding lost during rewriting</li> <li> <p>How fixed: Use <code>encoding_rs</code> to preserve charset</p> </li> <li> <p>Nested function minification: Added support in v0.2.0</p> </li> <li>What was missing: Closures couldn't be minified</li> <li> <p>How fixed: Enhanced scope tracking for nested scopes</p> </li> <li> <p>Diff context: Added <code>--diff-context</code> in v0.2.0</p> </li> <li>What was missing: Fixed 3-line context</li> <li>How fixed: Made configurable via CLI flag</li> </ol>"},{"location":"AGENTS/#openreported-issues","title":"Open/Reported Issues","text":"<p>(None currently reported; check GitHub issues)</p>"},{"location":"AGENTS/#future-work-roadmap","title":"Future Work &amp; Roadmap","text":""},{"location":"AGENTS/#high-priority","title":"High Priority","text":"<ol> <li>Call graph dead code detection</li> <li>Status: \u26a0\ufe0f Implemented but conservative</li> <li>Improvement: Add interprocedural analysis</li> <li> <p>Effort: Medium (requires PDG or similar)</p> </li> <li> <p><code>__all__</code> export analysis</p> </li> <li>Status: \u274c Not implemented</li> <li>Benefit: Better slim venv creation</li> <li> <p>Effort: Low-medium (pattern matching)</p> </li> <li> <p>Python 3.12+ support</p> </li> <li>Status: \u26a0\ufe0f Partial (no type params)</li> <li>Effort: Low (update rustpython-parser)</li> </ol>"},{"location":"AGENTS/#medium-priority","title":"Medium Priority","text":"<ol> <li>Call graph visualization</li> <li>Status: \u274c Not implemented</li> <li>Tool: <code>dot</code> / Graphviz output</li> <li> <p>Effort: Medium</p> </li> <li> <p>Incremental minification</p> </li> <li>Status: \u274c Not implemented</li> <li>Benefit: Cache plans between runs</li> <li> <p>Effort: High (requires fine-grained tracking)</p> </li> <li> <p>Multi-version plan generation</p> </li> <li>Status: \u274c Not implemented</li> <li>Benefit: Support Python 3.7-3.12 simultaneously</li> <li>Effort: Medium-high</li> </ol>"},{"location":"AGENTS/#low-priority-nice-to-have","title":"Low Priority / Nice-to-Have","text":"<ol> <li>IDE integration: VS Code extension for minify preview</li> <li>Web UI: Browser-based analyzer for large projects</li> <li>Machine learning optimization: Learn optimal package reduction ratios</li> <li>Multi-language support: Extend to JavaScript, Go, etc.</li> </ol>"},{"location":"AGENTS/#integration-points-external-apis","title":"Integration Points &amp; External APIs","text":""},{"location":"AGENTS/#command-line-api","title":"Command-Line API","text":"<pre><code># Analyze venv\ntsrs-cli analyze /path/to/venv\n\n# Create slim venv\ntsrs-cli slim &lt;python-dir&gt; &lt;venv-path&gt; [-o output]\n\n# Minify single file\ntsrs-cli minify path.py [--in-place] [--diff] [--stats]\n\n# Minify directory\ntsrs-cli minify-dir ./src [--out-dir ./out] [--jobs N]\n\n# Generate plan (no modification)\ntsrs-cli minify-plan path.py &gt; plan.json\ntsrs-cli minify-plan-dir src --out plan.json\n\n# Apply pre-generated plan\ntsrs-cli apply-plan path.py --plan plan.json [--in-place]\ntsrs-cli apply-plan-dir ./src --plan plan.json --out-dir ./out\n</code></pre>"},{"location":"AGENTS/#library-api-rust","title":"Library API (Rust)","text":"<pre><code>use tsrs::{MinifyPlan, VenvAnalyzer, Minifier};\n\n// Analyze venv\nlet analyzer = VenvAnalyzer::new(\"/path/to/venv\")?;\nlet packages = analyzer.analyze()?;\n\n// Generate minification plan\nlet minifier = Minifier::new();\nlet plan = minifier.plan_file(\"path/to/file.py\")?;\n\n// Serialize plan\nlet json = serde_json::to_string_pretty(&amp;plan)?;\n\n// Apply plan\nlet source = std::fs::read_to_string(\"path/to/file.py\")?;\nlet minified = minifier.apply_plan(&amp;source, &amp;plan)?;\n</code></pre>"},{"location":"AGENTS/#python-extension-pyo3","title":"Python Extension (PyO3)","text":"<p>When built with <code>python-extension</code> feature: <pre><code>import tsrs\n\nplan = tsrs.plan_minify(\"path/to/file.py\")\nminified_source = tsrs.apply_plan(source_code, plan)\n</code></pre></p> <p>(Status: Partially implemented, under active development)</p>"},{"location":"AGENTS/#common-pitfalls-how-to-avoid-them","title":"Common Pitfalls &amp; How to Avoid Them","text":""},{"location":"AGENTS/#1-renaming-globalnonlocal-variables","title":"1. Renaming Global/Nonlocal Variables","text":"<p>Problem: Function has <code>global x</code> or <code>nonlocal y</code>, and you minify <code>x</code>/<code>y</code> Result: Code breaks because renamed variable no longer refers to outer scope Prevention: <code>GlobalCollector</code> + <code>NonlocalCollector</code> explicitly track these Check: Search for <code>is_excluded_name()</code> call in minify logic</p>"},{"location":"AGENTS/#2-minifying-dunder-names","title":"2. Minifying Dunder Names","text":"<p>Problem: Rename <code>__init__</code> to <code>a</code> in a class Result: Reflection and pickle break; class becomes unusable Prevention: Hardcoded exclusion list for dunder names (<code>__*__</code>) Check: Test with <code>def __init__</code> in test suite</p>"},{"location":"AGENTS/#3-creating-plans-for-different-python-versions","title":"3. Creating Plans for Different Python Versions","text":"<p>Problem: Generate plan for Python 3.9 code, apply to Python 3.7 interpreter Result: Walrus operators, type hints may not parse in 3.7 Prevention: Lock plan format to source Python version Future: Add version compatibility checking in plan applier Check: Validate plan version matches target Python version</p>"},{"location":"AGENTS/#4-parallel-file-access-conflicts","title":"4. Parallel File Access Conflicts","text":"<p>Problem: Two threads try to minify same file with <code>--jobs N &gt; 1</code> Result: Corrupted output or panic Prevention: rayon handles independent files; use <code>--dry-run</code> first Check: Test directory minification with <code>--jobs 8</code> on large tree</p>"},{"location":"AGENTS/#5-incorrect-line-number-mapping","title":"5. Incorrect Line Number Mapping","text":"<p>Problem: Plan has line 100, but source code changed (imports added/removed) Result: Minify rewrites wrong variable Prevention: Always regenerate plans, don't reuse old plans Check: Version plans with source file hash or timestamp Current: No built-in versioning (task to add)</p>"},{"location":"AGENTS/#6-encoding-loss-during-rewrite","title":"6. Encoding Loss During Rewrite","text":"<p>Problem: UTF-8 file with BOM or UTF-16 file gets corrupted Result: Character encoding errors, file becomes unreadable Prevention: encoding_rs detects and preserves original encoding Status: \u2705 Fixed in v0.2.0 Check: Test with non-ASCII filenames and content</p>"},{"location":"AGENTS/#7-symlink-loops-in-directory-traversal","title":"7. Symlink Loops in Directory Traversal","text":"<p>Problem: Directory tree has symlink cycle (A \u2192 B \u2192 A) Result: Infinite loop or stack overflow Prevention: <code>--follow-symlinks</code> is opt-in, off by default Status: \u2705 Configurable in v0.2.0 Check: Test on directory with symlink cycle</p>"},{"location":"AGENTS/#quick-command-reference","title":"Quick Command Reference","text":""},{"location":"AGENTS/#testing","title":"Testing","text":"<pre><code>cargo test                  # All tests\ncargo test imports::        # Single module tests\ncargo test -- --nocapture  # Show println! output\n</code></pre>"},{"location":"AGENTS/#building","title":"Building","text":"<pre><code>cargo build                 # Debug\ncargo build --release       # Optimized\ncargo fmt &amp;&amp; cargo clippy -- -W clippy::pedantic\n</code></pre>"},{"location":"AGENTS/#cli-usage","title":"CLI Usage","text":"<pre><code># Minify one file (show what would change)\n./target/release/tsrs-cli minify src/main.py --diff\n\n# Minify one file (apply changes)\n./target/release/tsrs-cli minify src/main.py --in-place\n\n# Minify directory (dry-run with stats)\n./target/release/tsrs-cli minify-dir ./src --dry-run --stats --output-json stats.json\n\n# Create minification plan (for review/versioning)\n./target/release/tsrs-cli minify-plan-dir ./src --out plan.json\n\n# Apply pre-made plan\n./target/release/tsrs-cli apply-plan-dir ./src --plan plan.json --out-dir ./src-minified\n\n# Create minimal venv\n./target/release/tsrs-cli slim . .venv --json\n</code></pre>"},{"location":"AGENTS/#environment-variables","title":"Environment Variables","text":"<pre><code>RUST_LOG=debug cargo test -- --nocapture  # Debug logging\nRUST_LOG=tsrs=trace,rustpython=off        # Selective logging\n</code></pre>"},{"location":"AGENTS/#file-organization-where-to-find-things","title":"File Organization &amp; Where to Find Things","text":""},{"location":"AGENTS/#source-code-structure","title":"Source Code Structure","text":"<pre><code>src/\n\u251c\u2500\u2500 lib.rs                 # Library root, public API exports\n\u251c\u2500\u2500 bin/\n\u2502   \u2514\u2500\u2500 cli.rs             # CLI argument parsing and dispatch\n\u251c\u2500\u2500 imports.rs             # Import statement extraction\n\u251c\u2500\u2500 venv.rs                # Virtual environment analysis\n\u251c\u2500\u2500 callgraph.rs           # Function call graph, dead code detection\n\u251c\u2500\u2500 slim.rs                # Minimal venv creation\n\u251c\u2500\u2500 minify.rs              # Local variable minification\n\u2514\u2500\u2500 error.rs               # Error types\n\ntests/                      # Integration tests (if any)\n\ntest_packages/\n\u251c\u2500\u2500 test_unused_function/  # Dead code detection test\n\u251c\u2500\u2500 test_minify/           # Minification test samples\n\u2514\u2500\u2500 test_slim_packages/    # 16 import pattern tests\n\ndocs/\n\u251c\u2500\u2500 README.md              # User-facing overview\n\u251c\u2500\u2500 MINIFY_DESIGN.md       # Algorithm specification\n\u251c\u2500\u2500 TESTING.md             # Test infrastructure guide\n\u251c\u2500\u2500 CONTRIBUTING.md        # Contribution guidelines\n\u2514\u2500\u2500 API.md                 # Library API documentation\n</code></pre>"},{"location":"AGENTS/#where-to-find-specific-things","title":"Where to Find Specific Things","text":"What Where Minification exclusions (dunder, keywords) <code>src/minify.rs</code> line ~50-150 Python keyword list <code>src/minify.rs</code> line ~100 Builtin name list <code>src/minify.rs</code> line ~120 Name generation algorithm <code>src/minify.rs</code> - <code>ShortNameGen</code> struct Import pattern matching <code>src/imports.rs</code> line ~100+ Plan serialization <code>src/minify.rs</code> - <code>MinifyPlan</code> struct CLI command definitions <code>src/bin/cli.rs</code> - <code>#[derive(Subcommand)]</code> Venv discovery <code>src/venv.rs</code> - <code>VenvAnalyzer::new()</code> Call graph building <code>src/callgraph.rs</code> - <code>CallGraphAnalyzer</code>"},{"location":"AGENTS/#how-to-contribute-effectively","title":"How to Contribute Effectively","text":"<ol> <li>Before starting: Check current issues and recent PRs (GitHub)</li> <li>Pick a task: From \"Future Work\" section or GitHub issues</li> <li>Create a branch: <code>git checkout -b feature/my-feature</code></li> <li>Implement with tests: Add unit tests for new logic</li> <li>Run checks locally: <code>cargo fmt &amp;&amp; cargo clippy -- -W clippy::pedantic &amp;&amp; cargo test</code></li> <li>Commit: Follow conventional commits (<code>feat:</code>, <code>fix:</code>, <code>docs:</code>, etc.)</li> <li>Push &amp; create PR: Link to any relevant issues</li> <li>Wait for CI: Ensure all tests pass</li> <li>Address review feedback: Make requested changes</li> <li>Merge: Maintainer will merge when approved</li> </ol>"},{"location":"AGENTS/#version-history-quick-reference","title":"Version History Quick Reference","text":""},{"location":"AGENTS/#v020-2025-11-01-current","title":"v0.2.0 (2025-11-01) - Current","text":"<p>Major Features: - Encoding preservation (BOM, UTF-8, line endings) - Nested function minification - Diff improvements (<code>--diff-context</code>) - Directory safety flags (hidden files, symlinks, <code>.gitignore</code>) - Parallel processing with <code>--jobs N</code> - JSON stats output (<code>--output-json</code>) - Streaming support (stdin/stdout) - Comprehensive error handling</p> <p>File Changes: - Enhanced <code>src/minify.rs</code> for nested scopes - Updated <code>src/bin/cli.rs</code> with new flags - Added <code>encoding_rs</code> and <code>ignore</code> dependencies</p>"},{"location":"AGENTS/#v010-earlier","title":"v0.1.0 (Earlier)","text":"<p>Basic Features: - Core minification - CLI interface - Basic venv slimming - Plan generation</p> <p>Limitations: - Encoding loss during rewriting - No nested function support - Limited CLI options</p>"},{"location":"AGENTS/#next-steps-for-contributors","title":"Next Steps for Contributors","text":"<p>If improving code quality: Review <code>MINIFY_DESIGN.md</code> for detailed algorithm specification</p> <p>If adding features: Check <code>Future Work</code> section and GitHub issues</p> <p>If fixing bugs: Use debug logging (<code>RUST_LOG=debug</code>) and test on <code>test_packages/</code></p> <p>If documenting: Update relevant <code>.md</code> file and ensure consistency with code</p> <p>Questions? Check inline code comments and see <code>src/minify.rs</code> for detailed explanations of scope rules.</p> <p>Last Updated: 2025-11-01 Maintainer: George Pearse Repository: https://github.com/georgepearse/tsrs</p>"},{"location":"ALTERNATIVE_APPROACHES/","title":"Alternative Approaches: Python Optimization Strategies","text":"<p>This document explores alternative architectural approaches to Python code optimization and tree-shaking, comparing them to tsrs' current static analysis strategy.</p>"},{"location":"ALTERNATIVE_APPROACHES/#overview","title":"Overview","text":"<p>The core question: Is it easier to compile Python to Rust/C++, minify the compiled artifact, then convert back to Python?</p> <p>Short answer: No, for most use cases. This document explains why and explores the trade-offs.</p>"},{"location":"ALTERNATIVE_APPROACHES/#current-approach-static-analysis-direct-minification","title":"Current Approach: Static Analysis + Direct Minification","text":"<p>tsrs uses direct Python AST analysis:</p> <pre><code>Python Source\n    \u2193\n[rustpython-parser] \u2192 AST\n    \u2193\n[ImportCollector] \u2192 Extract imports/used symbols\n    \u2193\n[CallGraphAnalyzer] \u2192 Detect dead code\n    \u2193\n[Minifier] \u2192 Rename locals, strip docstrings\n    \u2193\n[VenvSlimmer] \u2192 Copy only needed packages\n    \u2193\nMinified Python\n</code></pre>"},{"location":"ALTERNATIVE_APPROACHES/#advantages","title":"Advantages \u2705","text":"<ul> <li>Language-agnostic: Works on any Python version the parser supports</li> <li>Byte-for-byte predictable: Source remains Python, understable, debuggable</li> <li>Fast: Single-pass analysis, linear in code size</li> <li>Non-invasive: No compilation overhead, no runtime dependencies</li> <li>Composable: Can combine with other tools (build systems, type checkers)</li> <li>Reversible: Can always regenerate plans from fresh source</li> <li>Distribution: Artifact is still Python\u2014run anywhere without compilation</li> <li>Optimization: Tailored to Python semantics (imports, scoping, builtins)</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#limitations","title":"Limitations \u26a0\ufe0f","text":"<ol> <li>Conservative on dynamic features: Can't track <code>importlib.import_module()</code> or string-based <code>eval()</code></li> <li>Per-package dead code: Call graphs don't cross package boundaries</li> <li>No cross-module inlining: Functions aren't merged or inlined</li> <li>Limited type information: No flow analysis for type-specific optimizations</li> <li>Slow on large files: AST parsing of 100KB+ files can bottleneck</li> </ol>"},{"location":"ALTERNATIVE_APPROACHES/#alternative-1-python-rust-python","title":"Alternative 1: Python \u2192 Rust \u2192 Python","text":"<p>Idea: Use tools like <code>PyO3</code> or <code>maturin</code> to compile Python modules to Rust, minify the Rust, then expose Python bindings.</p>"},{"location":"ALTERNATIVE_APPROACHES/#how-it-would-work","title":"How it would work","text":"<pre><code>Python Source (e.g., main.py)\n    \u2193\n[maturin / PyO3] \u2192 Rust code (generated or hand-written)\n    \u2193\n[Rust compiler] \u2192 Minified binary (LLVM optimizations)\n    \u2193\n[PyO3 binding generator] \u2192 Python wrapper modules\n    \u2193\nPython module (now backed by Rust binary)\n</code></pre>"},{"location":"ALTERNATIVE_APPROACHES/#advantages_1","title":"Advantages \u2705","text":"<ul> <li>Deep optimization: LLVM IR passes, vectorization, aggressive inlining</li> <li>Type inference: Rust compiler provides full type analysis</li> <li>Proven ecosystem: Rust has mature code generation and optimization tools</li> <li>Runtime speed: Compiled code runs 10-100x faster than interpreted Python</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#disadvantages","title":"Disadvantages \u274c","text":"Problem Impact Compilation time 30-60s per module for typical projects; can't do incremental iteration Binary compatibility Must recompile for each Python version (3.7, 3.9, 3.11, 3.12) and platform (Linux/x86, macOS/M1, Windows) Distribution complexity Ship compiled <code>.so</code> / <code>.pyd</code> files instead of <code>.py</code>; wheels required per arch/Python combo Debugging difficulty Stack traces point to Rust code, not original Python; harder to patch/modify Loss of portability Can't run on unexpected architectures (e.g., wasm, embedded systems) Reverse engineering cost Minified Rust binary can't be reverse-engineered; harms transparency AST generation Must parse Python \u2192 generate idiomatic Rust \u2192 let compiler optimize; many loss opportunities Dynamic features Python's <code>eval()</code>, <code>exec()</code>, reflection harder to support in Rust bindings Dependency management Rust deps add to supply chain; licensing complexity (Rust crate ecosystem vs. PyPI)"},{"location":"ALTERNATIVE_APPROACHES/#real-world-example-why-this-fails","title":"Real-world example: Why this fails","text":"<p>Scenario: User has a 500-line script using <code>pandas</code>, <code>numpy</code>, <code>scikit-learn</code>.</p> <p>With tsrs: <pre><code>$ tsrs slim . .venv-slim        # 2s\n$ ls -lh .venv-slim/lib/python3.11/site-packages\n# Result: 150MB (down from 2.5GB)\n</code></pre></p> <p>With compile-to-Rust: <pre><code>$ cargo new --lib my_project    # Create Rust project\n$ maturin develop               # Wait 45s for compilation\n$ # Error: scikit-learn has C extensions, can't auto-convert to Rust\n$ # Error: pandas uses numpy C API, manual bindings needed\n$ # Error: Dead code in Rust lib still compiled (LLVM can't cross module boundaries)\n</code></pre></p> <p>Outcome: \u274c Not viable for mixed Python/C extension projects (most real-world projects)</p>"},{"location":"ALTERNATIVE_APPROACHES/#alternative-2-python-c-python","title":"Alternative 2: Python \u2192 C++ \u2192 Python","text":"<p>Idea: Similar to Rust, but using tools like <code>pybind11</code> or <code>SWIG</code> to wrap C++ code.</p>"},{"location":"ALTERNATIVE_APPROACHES/#how-it-would-work_1","title":"How it would work","text":"<pre><code>Python Source\n    \u2193\n[Code generator] \u2192 C++ code\n    \u2193\n[C++ compiler (g++/clang)] \u2192 Optimized binary\n    \u2193\n[pybind11] \u2192 Python bindings\n    \u2193\nPython module (backed by C++)\n</code></pre>"},{"location":"ALTERNATIVE_APPROACHES/#advantages_2","title":"Advantages \u2705","text":"<ul> <li>Familiar ecosystem: Many Python projects already use C++ bindings (OpenCV, TensorFlow, etc.)</li> <li>Optimization: Similar compiler optimizations as Rust approach</li> <li>Mature tooling: <code>pybind11</code>, <code>SWIG</code> are well-tested</li> <li>Performance: Can exploit SIMD, multithreading at C++ level</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#disadvantages_1","title":"Disadvantages \u274c","text":"<p>Worse than Rust approach because:</p> Problem Impact Slower compilation C++ templates, header bloat \u2192 60-120s per build ABI fragmentation C++ name mangling differs per compiler; Windows/Linux incompatible Less optimization C++ doesn't have Rust's borrow checker; can't remove as many bounds checks Manual memory management Risk of leaks, buffer overflows when translating Python logic to C++ Harder code generation Python's dynamic typing \u2192 C++ generics/templates = explosion of template instantiations Build complexity Requires CMake, Make, or Bazel; harder to distribute wheels Debugging Stack traces even harder to interpret; C++ runtime overhead"},{"location":"ALTERNATIVE_APPROACHES/#example-failure","title":"Example failure","text":"<p>Goal: Minify a 1MB codebase, reducing to 500KB.</p> <pre><code># C++ approach:\npython -m cppyy --generate code.py &gt; generated.cpp  # Generate C++ (500KB)\nclang++ -O3 -fvisibility=hidden generated.cpp -o code.so  # Compile (80s)\n# Result: .so file is 2.3MB (larger than original Python!)\n# Reason: Debug symbols, exception handling, C++ stdlib overhead\n</code></pre> <p>With tsrs: <pre><code>tsrs minify-dir . --in-place  # 100ms\n# Result: Original .py files now 450KB (20% reduction)\n</code></pre></p>"},{"location":"ALTERNATIVE_APPROACHES/#alternative-3-bytecode-compilation-optimization","title":"Alternative 3: Bytecode Compilation + Optimization","text":"<p>Idea: Compile Python to bytecode (<code>.pyc</code>), optimize bytecode, then distribute obfuscated bytecode.</p>"},{"location":"ALTERNATIVE_APPROACHES/#how-it-would-work_2","title":"How it would work","text":"<pre><code>Python Source\n    \u2193\n[py_compile] \u2192 .pyc bytecode\n    \u2193\n[Custom optimizer] \u2192 Remove dead code, inline constants\n    \u2193\n[Obfuscator] \u2192 Unreadable but functional\n    \u2193\nOptimized .pyc distribution\n</code></pre>"},{"location":"ALTERNATIVE_APPROACHES/#advantages_3","title":"Advantages \u2705","text":"<ul> <li>No compilation: Runs directly in Python interpreter</li> <li>Simple tooling: Leverage existing <code>marshal</code>, <code>dis</code> modules</li> <li>Partial success: Can remove simple dead code at bytecode level</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#disadvantages_2","title":"Disadvantages \u274c","text":"Problem Impact Limited optimization Bytecode optimizer doesn't understand high-level semantics Version fragility <code>.pyc</code> format changes per Python version; .pyc from 3.9 won't load in 3.11 No venv slimming Doesn't remove unused packages (only bytecode, not modules) Obfuscation != minification Bytecode still exposes names, function signatures Startup overhead Still parsing/unmarshalling bytecode on each import CPython internals Deeply coupled to CPython implementation; breaks on PyPy/Jython"},{"location":"ALTERNATIVE_APPROACHES/#why-this-doesnt-work","title":"Why this doesn't work","text":"<pre><code># Original\ndef helper():\n    pass\n\ndef main():\n    return 42\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Bytecode optimizer sees: - Functions are bytecode objects \u2192 can't determine if <code>helper()</code> is called - Names are strings in code objects \u2192 can't track symbol usage across functions - Imports are opcode LOAD_CONST \u2192 can't statically resolve module dependencies</p> <p>Result: \u274c Can't remove <code>helper()</code> function</p>"},{"location":"ALTERNATIVE_APPROACHES/#alternative-4-hybrid-static-analysis-selective-compilation","title":"Alternative 4: Hybrid: Static Analysis + Selective Compilation","text":"<p>Idea: Use tsrs-style analysis to identify what could be compiled, compile only hot paths, leave rest as Python.</p>"},{"location":"ALTERNATIVE_APPROACHES/#how-it-would-work_3","title":"How it would work","text":"<pre><code>Python Source\n    \u2193\n[CallGraphAnalyzer] \u2192 Identify hot functions\n    \u2193\n\u251c\u2500\u2192 Hot functions \u2192 [Rust codegen] \u2192 Binary\n\u2514\u2500\u2192 Cold functions \u2192 [Minifier] \u2192 Minified Python\n    \u2193\nHybrid: .so + minified .py\n</code></pre>"},{"location":"ALTERNATIVE_APPROACHES/#advantages_4","title":"Advantages \u2705","text":"<ul> <li>Best of both: Python's flexibility + Rust's speed where it matters</li> <li>Incremental: Can compile single functions without recompiling whole module</li> <li>Reasonable distribution: Ship minimal <code>.so</code> + most code as Python</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#disadvantages_3","title":"Disadvantages \u274c","text":"Problem Impact Tool complexity Must build code gen, binding gen, incremental compilation system Profiling required Need benchmarks to identify \"hot\" code; guessing is unreliable Cross-platform builds Still requires wheels per platform/Python version JIT competing PyPy's JIT or modern CPython's JIT (3.13+) compile hot code at runtime; hybrid approach less valuable Maintenance burden Two codebases (Python + Rust) to maintain in sync"},{"location":"ALTERNATIVE_APPROACHES/#when-this-makes-sense","title":"When this makes sense","text":"<ul> <li>Scientific computing: Matrix operations (numpy) often bottleneck \u2192 worth compiling</li> <li>Game loops: Tight rendering loops benefit from Rust compilation</li> <li>Data processing: CSV parsing, regex matching \u2192 compile-worthy</li> </ul> <p>But not for: General-purpose code, most business logic, prototype projects</p>"},{"location":"ALTERNATIVE_APPROACHES/#alternative-5-link-time-optimization-lto-static-analysis","title":"Alternative 5: Link-Time Optimization (LTO) + Static Analysis","text":"<p>Idea: Analyze Python source to build a \"static library\" of all symbols, then use linker-level optimization to remove unused symbols before shipping.</p>"},{"location":"ALTERNATIVE_APPROACHES/#how-it-would-work_4","title":"How it would work","text":"<pre><code>Python Source\n    \u2193\n[AST analysis] \u2192 Build symbol table (imports + definitions)\n    \u2193\n[Dead code detection] \u2192 Mark unused symbols\n    \u2193\n[Symbol stripping] \u2192 Remove from .pyc/wheel metadata\n    \u2193\n[Distribute] \u2192 Wheel without dead code metadata\n</code></pre>"},{"location":"ALTERNATIVE_APPROACHES/#advantages_5","title":"Advantages \u2705","text":"<ul> <li>Minimal tooling: Builds on tsrs' existing analysis</li> <li>No compilation: Pure Python distribution</li> <li>Fast: Single pass</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#disadvantages_4","title":"Disadvantages \u274c","text":"Problem Impact Metadata only: Doesn't actually remove bytecode, just marks symbols invisible Import side effects: Removed code might have side effects; hard to know No venv slimming: Still must distribute all packages <p>Verdict: \u274c Doesn't provide much benefit over current tsrs approach</p>"},{"location":"ALTERNATIVE_APPROACHES/#comparison-matrix","title":"Comparison Matrix","text":"Approach Compile Time Distribution Runtime Speed Debuggability Works with C Extensions Complexity tsrs (Current) 0.1s Pure Python 1.0x Excellent \u2705 Low Python\u2192Rust 45s Wheels (per arch) 10x Poor \u274c Very High Python\u2192C++ 80s Wheels (per arch) 8x Poor \u26a0\ufe0f Limited Very High Bytecode optimization 1s .pyc files 1.1x Medium \u2705 Medium Hybrid (Rust + Python) 30s Wheels + .py 5x Medium \u26a0\ufe0f Limited Very High LTO + Static Analysis 0.1s Pure Python 1.0x Excellent \u2705 Low"},{"location":"ALTERNATIVE_APPROACHES/#why-tsrs-uses-static-analysis","title":"Why tsrs Uses Static Analysis","text":""},{"location":"ALTERNATIVE_APPROACHES/#design-rationale","title":"Design Rationale","text":"<p>tsrs prioritizes correctness and usability over aggressive optimization:</p> <ol> <li>Conservative approach: Never remove code we're unsure about</li> <li>Compilation strategies must make assumptions (e.g., \"this symbol won't be dynamically imported\")</li> <li> <p>Static analysis can be conservative: if we're not sure, keep it</p> </li> <li> <p>Pure Python output: Preserve auditability and portability</p> </li> <li>Binaries can't be audited by security researchers</li> <li>Won't run on unexpected architectures (ARM servers, WebAssembly, etc.)</li> <li> <p>Users can read, modify, understand the optimized code</p> </li> <li> <p>No vendor lock-in: Works with any Python distribution</p> </li> <li>PyPy, Jython, CPython, Pyston\u2014all supported</li> <li>No dependency on Rust/C++ ecosystems</li> <li> <p>No license compatibility concerns (Python PSF vs. Rust community)</p> </li> <li> <p>Integration-friendly: Fits into existing toolchains</p> </li> <li>Works with pytest, mypy, pylint, black</li> <li>Compatible with pre-commit hooks, CI/CD pipelines</li> <li> <p>No rebuild step when source changes</p> </li> <li> <p>Composability: Can combine with other tools</p> </li> <li>Stack with type checkers (reveal unused imports)</li> <li>Layer with formatters and linters</li> <li>Build custom analysis on top of tsrs plans</li> </ol>"},{"location":"ALTERNATIVE_APPROACHES/#when-you-should-consider-alternatives","title":"When You SHOULD Consider Alternatives","text":""},{"location":"ALTERNATIVE_APPROACHES/#scenario-1-performance-critical-inner-loops","title":"Scenario 1: Performance-Critical Inner Loops","text":"<p>If: Your application has tight loops (image processing, numerical simulation, game rendering)</p> <p>Try: Compile hot path to Rust/C++ via <code>PyO3</code> or <code>pybind11</code></p> <p>Why: 10-100x speedup beats any minification</p> <p>Example: <pre><code>// In Rust\n#[pyfunction]\nfn process_pixels(data: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt; {\n    data.into_iter().map(|x| x.saturating_add(50)).collect()\n}\n</code></pre></p>"},{"location":"ALTERNATIVE_APPROACHES/#scenario-2-strict-security-obfuscation-requirement","title":"Scenario 2: Strict Security / Obfuscation Requirement","text":"<p>If: You need to hide algorithm or prevent tampering</p> <p>Try: Compile to binary using Rust/C++, or use obfuscators like <code>Nuitka</code></p> <p>Why: Pure Python can be read by anyone with access</p> <p>Example: Proprietary ML model inference (compile to binary)</p>"},{"location":"ALTERNATIVE_APPROACHES/#scenario-3-standalone-executables","title":"Scenario 3: Standalone Executables","text":"<p>If: You need <code>.exe</code> / single binary distribution (no Python dependency)</p> <p>Try: <code>PyInstaller</code>, <code>py2exe</code>, or compile to Rust (<code>RustPython</code>)</p> <p>Why: Reduces friction for end-users (no Python install needed)</p>"},{"location":"ALTERNATIVE_APPROACHES/#scenario-4-real-time-constraints-sub-millisecond","title":"Scenario 4: Real-Time Constraints (Sub-millisecond)","text":"<p>If: Latency budget is &lt;1ms per operation</p> <p>Try: Compile to Rust/C++ or use PyPy + JIT</p> <p>Why: Python interpretation overhead is significant at microsecond scales</p>"},{"location":"ALTERNATIVE_APPROACHES/#hybrid-strategy-multi-optimization-toolkit","title":"Hybrid Strategy: Multi-Optimization Toolkit","text":"<p>The best approach is often layered:</p> <pre><code>1. Run tsrs to minify code + slim venvs           (0% overhead, 30-70% reduction)\n   \u2193\n2. Run black/isort to standardize formatting       (0% overhead, improves tooling)\n   \u2193\n3. Run mypy to catch type errors                   (0% overhead, improves reliability)\n   \u2193\n4. For hot code only:\n   \u251c\u2500\u2192 Option A: Rewrite in Rust via PyO3        (for 10x+ speedup needs)\n   \u2514\u2500\u2192 Option B: Use PyPy / Cython               (for 2-5x speedup)\n   \u2193\n5. Package with `pip install` / `poetry`          (standard distribution)\n</code></pre> <p>Result: - 30-70% smaller deployments (tsrs) - 2-10x faster execution (PyPy or selective compilation) - Debuggable, auditable, maintainable code - Works everywhere</p>"},{"location":"ALTERNATIVE_APPROACHES/#recommended-reading","title":"Recommended Reading","text":"<ul> <li>Rust/Python Interop: https://pyo3.rs/v0.20.0/</li> <li>Type Optimization: https://github.com/numba/numba (JIT compiler for numerical code)</li> <li>Bytecode Obfuscation: https://github.com/Taiga74164/python-bytecode-obfuscator</li> <li>Nuitka (Python compiler to C++): https://nuitka.net/</li> <li>PyPy (alternative Python interpreter with JIT): https://www.pypy.org/</li> </ul>"},{"location":"ALTERNATIVE_APPROACHES/#conclusion","title":"Conclusion","text":"<p>For general-purpose Python code optimization, static analysis (tsrs' approach) is superior to compilation-based strategies.</p> <p>Compilation is valuable when: - Performance is critical and profiling shows a bottleneck - Distribution must hide source code - Single binary executable is required - Real-time constraints exist</p> <p>For everything else: - Use tsrs for dead code removal and venv slimming - Use formatters/linters for code quality - Use PyPy or PyUpgrade for incremental performance gains - Compile only identified hot paths if needed</p> <p>Last Updated: 2025-11-01 Author: tsrs Architecture Team</p>"},{"location":"API/","title":"API Reference","text":"<p>This document describes the public API of the tsrs library for programmatic use.</p>"},{"location":"API/#overview","title":"Overview","text":"<p>The tsrs library provides Rust modules for analyzing Python code and virtual environments. It can be used as a library in other Rust projects or integrated with Python via PyO3.</p>"},{"location":"API/#core-modules","title":"Core Modules","text":""},{"location":"API/#venv-module","title":"venv Module","text":"<p>Analyze Python virtual environments and discover installed packages.</p> <pre><code>use tsrs::venv::{VenvAnalyzer, VenvInfo, PackageInfo};\n\n// Create an analyzer for a virtual environment\nlet analyzer = VenvAnalyzer::new(\"/path/to/.venv\")?;\n\n// Get information about the venv\nlet venv_info = analyzer.analyze()?;\n\n// Print package names\nfor package in &amp;venv_info.packages {\n    println!(\"Package: {}\", package.name);\n    if let Some(version) = &amp;package.version {\n        println!(\"  Version: {}\", version);\n    }\n}\n</code></pre>"},{"location":"API/#venvanalyzer","title":"VenvAnalyzer","text":"<pre><code>pub struct VenvAnalyzer {\n    venv_path: PathBuf,\n}\n\nimpl VenvAnalyzer {\n    /// Create a new venv analyzer\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the venv path does not exist.\n    pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self&gt;;\n\n    /// Analyze the venv and collect package information\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the analysis fails.\n    pub fn analyze(&amp;self) -&gt; Result&lt;VenvInfo&gt;;\n}\n</code></pre>"},{"location":"API/#venvinfo","title":"VenvInfo","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VenvInfo {\n    /// Path to the venv\n    pub path: PathBuf,\n    /// Python version (if detectable)\n    pub python_version: Option&lt;String&gt;,\n    /// List of installed packages\n    pub packages: Vec&lt;PackageInfo&gt;,\n}\n</code></pre>"},{"location":"API/#packageinfo","title":"PackageInfo","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct PackageInfo {\n    /// Package name\n    pub name: String,\n    /// Package version\n    pub version: Option&lt;String&gt;,\n    /// Path to the package\n    pub path: PathBuf,\n}\n</code></pre>"},{"location":"API/#imports-module","title":"imports Module","text":"<p>Extract and track import statements from Python source code.</p> <pre><code>use tsrs::imports::{ImportCollector, ImportSet};\nuse std::path::Path;\n\n// Create a collector\nlet mut collector = ImportCollector::new();\n\n// Collect from a file\ncollector.collect_from_file(\"src/main.py\")?;\n\n// Get all imports\nlet imports = collector.get_imports();\nfor import in imports.get_imports() {\n    println!(\"Import: {}\", import);\n}\n</code></pre>"},{"location":"API/#importcollector","title":"ImportCollector","text":"<pre><code>pub struct ImportCollector {\n    imports: ImportSet,\n}\n\nimpl ImportCollector {\n    /// Create a new import collector\n    #[must_use]\n    pub fn new() -&gt; Self;\n\n    /// Parse a Python file and extract imports\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read or parsed.\n    pub fn collect_from_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Result&lt;()&gt;;\n\n    /// Parse Python source code and extract imports\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed.\n    pub fn collect_from_source(&amp;mut self, source: &amp;str) -&gt; Result&lt;()&gt;;\n\n    /// Get collected imports\n    #[must_use]\n    pub fn get_imports(&amp;self) -&gt; ImportSet;\n}\n</code></pre>"},{"location":"API/#importset","title":"ImportSet","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct ImportSet {\n    pub imports: HashSet&lt;String&gt;,\n}\n\nimpl ImportSet {\n    /// Create a new import set\n    #[must_use]\n    pub fn new() -&gt; Self;\n\n    /// Add an import\n    pub fn add(&amp;mut self, import: String);\n\n    /// Get all imports\n    #[must_use]\n    pub fn get_imports(&amp;self) -&gt; Vec&lt;String&gt;;\n}\n</code></pre>"},{"location":"API/#callgraph-module","title":"callgraph Module","text":"<p>Analyze function definitions and calls to build call graphs.</p> <pre><code>use tsrs::callgraph::CallGraphAnalyzer;\n\n// Create analyzer\nlet mut analyzer = CallGraphAnalyzer::new()?;\n\n// Analyze a Python file\nanalyzer.analyze_file(\"module.py\", \"mypackage\")?;\n\n// Find unused functions\nlet unused = analyzer.find_unused_functions(\"mypackage\");\nfor func_name in unused {\n    println!(\"Unused: {}\", func_name);\n}\n\n// Find external dependencies\nlet external = analyzer.find_external_dependencies();\nfor dep in external {\n    println!(\"External dependency: {}\", dep);\n}\n</code></pre>"},{"location":"API/#callgraphanalyzer","title":"CallGraphAnalyzer","text":"<pre><code>pub struct CallGraphAnalyzer {\n    graphs: HashMap&lt;String, PackageCallGraph&gt;,\n}\n\nimpl CallGraphAnalyzer {\n    /// Create a new call graph analyzer\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if regex compilation fails.\n    pub fn new() -&gt; Result&lt;Self&gt;;\n\n    /// Analyze a Python file and build call graph\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be read.\n    pub fn analyze_file&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P, package: &amp;str) -&gt; Result&lt;()&gt;;\n\n    /// Get all call graphs\n    #[must_use]\n    pub fn get_graphs(&amp;self) -&gt; &amp;HashMap&lt;String, PackageCallGraph&gt;;\n\n    /// Get call graph for a specific package\n    #[must_use]\n    pub fn get_graph(&amp;self, package: &amp;str) -&gt; Option&lt;&amp;PackageCallGraph&gt;;\n\n    /// Find unused functions in a package\n    #[must_use]\n    pub fn find_unused_functions(&amp;self, package: &amp;str) -&gt; HashSet&lt;String&gt;;\n\n    /// Find all external dependencies\n    #[must_use]\n    pub fn find_external_dependencies(&amp;self) -&gt; HashSet&lt;String&gt;;\n}\n</code></pre>"},{"location":"API/#slim-module","title":"slim Module","text":"<p>Create minimal virtual environments based on code analysis.</p> <pre><code>use tsrs::slim::VenvSlimmer;\n\n// Create slimmer with default output\nlet mut slimmer = VenvSlimmer::new(\"./src\", \"./.venv\")?;\nslimmer.slim()?;\n// Creates ./.venv-slim\n\n// Or specify custom output\nlet mut slimmer = VenvSlimmer::new_with_output(\n    \"./src\",\n    \"./.venv\",\n    \"./output/.venv-slim\"\n)?;\nslimmer.slim()?;\n</code></pre>"},{"location":"API/#venvslimmer","title":"VenvSlimmer","text":"<pre><code>pub struct VenvSlimmer {\n    code_directory: PathBuf,\n    source_venv: PathBuf,\n    output_venv: PathBuf,\n}\n\nimpl VenvSlimmer {\n    /// Create a new venv slimmer that analyzes code_directory and slims source_venv\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if either path does not exist.\n    pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(code_directory: P, source_venv: P) -&gt; Result&lt;Self&gt;;\n\n    /// Create a new venv slimmer with custom output path\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if either path does not exist.\n    pub fn new_with_output&lt;P: AsRef&lt;Path&gt;&gt;(\n        code_directory: P,\n        source_venv: P,\n        output_venv: P,\n    ) -&gt; Result&lt;Self&gt;;\n\n    /// Create a slim venv by analyzing code imports and copying only used packages\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the analysis or copying fails.\n    pub fn slim(&amp;self) -&gt; Result&lt;()&gt;;\n}\n</code></pre>"},{"location":"API/#minify-module","title":"minify Module","text":"<p>Analyze and rewrite Python code with minified local variable names.</p> <pre><code>use tsrs::minify::Minifier;\n\n// Create a minification plan\nlet plan = Minifier::plan_from_source(\"mymodule\", source_code)?;\n\n// Rewrite code with the plan\nlet minified = Minifier::rewrite_with_plan(\"mymodule\", source_code, &amp;plan)?;\nprintln!(\"{}\", minified);\n</code></pre>"},{"location":"API/#minifier","title":"Minifier","text":"<pre><code>pub struct Minifier;\n\nimpl Minifier {\n    /// Build a plan for renaming local symbols in every function contained in the source\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed.\n    pub fn plan_from_source(module_name: &amp;str, source: &amp;str) -&gt; Result&lt;MinifyPlan&gt;;\n\n    /// Rewrite source code by applying planned renames when no nested functions are present\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed or planned.\n    pub fn rewrite_source(module_name: &amp;str, source: &amp;str) -&gt; Result&lt;String&gt;;\n\n    /// Rewrite using a precomputed plan, enabling plan curation before application\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the source cannot be parsed.\n    pub fn rewrite_with_plan(\n        module_name: &amp;str,\n        source: &amp;str,\n        plan: &amp;MinifyPlan,\n    ) -&gt; Result&lt;String&gt;;\n}\n</code></pre>"},{"location":"API/#minifyplan","title":"MinifyPlan","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MinifyPlan {\n    pub module: String,\n    pub keywords: HashSet&lt;String&gt;,\n    pub functions: Vec&lt;FunctionPlan&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FunctionPlan {\n    pub qualified_name: String,\n    pub renames: Vec&lt;RenameEntry&gt;,\n    pub range: Option&lt;FunctionRange&gt;,\n    pub has_nested_functions: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\npub struct RenameEntry {\n    pub original: String,\n    pub renamed: String,\n}\n\n#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\npub struct FunctionRange {\n    pub start: usize,\n    pub end: usize,\n}\n</code></pre>"},{"location":"API/#error-handling","title":"Error Handling","text":"<p>All fallible operations return <code>Result&lt;T&gt;</code>:</p> <pre><code>use tsrs::error::{Result, TsrsError};\n\nmatch some_operation() {\n    Ok(value) =&gt; println!(\"Success: {}\", value),\n    Err(TsrsError::ParseError(msg)) =&gt; eprintln!(\"Parse error: {}\", msg),\n    Err(TsrsError::Io(err)) =&gt; eprintln!(\"IO error: {}\", err),\n    Err(TsrsError::InvalidVenvPath(msg)) =&gt; eprintln!(\"Invalid venv: {}\", msg),\n}\n</code></pre>"},{"location":"API/#examples","title":"Examples","text":""},{"location":"API/#complete-analysis-workflow","title":"Complete Analysis Workflow","text":"<pre><code>use tsrs::{\n    venv::VenvAnalyzer,\n    imports::ImportCollector,\n    callgraph::CallGraphAnalyzer,\n    slim::VenvSlimmer,\n};\n\nfn main() -&gt; tsrs::error::Result&lt;()&gt; {\n    // 1. Analyze venv\n    let analyzer = VenvAnalyzer::new(\"./.venv\")?;\n    let venv_info = analyzer.analyze()?;\n    println!(\"Found {} packages\", venv_info.packages.len());\n\n    // 2. Collect imports from code\n    let mut import_collector = ImportCollector::new();\n    import_collector.collect_from_file(\"./src/main.py\")?;\n    let imports = import_collector.get_imports();\n    println!(\"Found {} imports\", imports.get_imports().len());\n\n    // 3. Build call graph\n    let mut call_graph = CallGraphAnalyzer::new()?;\n    call_graph.analyze_file(\"./src/main.py\", \"myapp\")?;\n    let unused = call_graph.find_unused_functions(\"myapp\");\n    println!(\"Found {} unused functions\", unused.len());\n\n    // 4. Create slim venv\n    let slimmer = VenvSlimmer::new(\"./src\", \"./.venv\")?;\n    slimmer.slim()?;\n    println!(\"Created slim venv\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"API/#thread-safety","title":"Thread Safety","text":"<p>All public types are safe to use across threads. The library uses: - <code>Arc</code> for shared state - <code>Mutex</code> where needed for interior mutability - No global mutable state</p>"},{"location":"API/#performance-notes","title":"Performance Notes","text":"<ul> <li>Parallel Processing: Directory operations use <code>rayon</code> for parallelization</li> <li>Caching: Import sets use <code>HashSet</code> for O(1) lookups</li> <li>Streaming: Large files are streamed where possible</li> <li>Allocation: Minimal allocations in hot paths</li> </ul>"},{"location":"API/#version-compatibility","title":"Version Compatibility","text":"<ul> <li>Rust: 1.75+</li> <li>Python: 3.8+ (for code being analyzed)</li> </ul>"},{"location":"API/#see-also","title":"See Also","text":"<ul> <li>MINIFY_DESIGN.md - Minification algorithm details</li> <li>README.md - Project overview and CLI usage</li> <li>TESTING.md - Testing guide</li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"CHANGELOG/#020-2025-11-01","title":"0.2.0 \u2013 2025-11-01","text":"<ul> <li>Preserve file encodings, BOMs, line endings, and trailing-newline state when rewriting   Python sources, ensuring byte-for-byte compatibility where possible.</li> <li>Support nested-function planning and rewriting, enabling safe local renames inside   closures and class bodies.</li> <li>Expand CLI glob controls: explicit <code>--glob-case-insensitive</code>, default behaviour on   Windows, pattern include/exclude files, and <code>--max-depth</code> traversal limits.</li> <li>Add diff UX controls (<code>--diff</code> with <code>--diff-context</code>), dry-run output, and <code>--stats</code>   JSON reporting (including <code>--output-json</code>).</li> <li>Introduce directory safety flags: include/exclude hidden files, follow symlinks,   respect <code>.gitignore</code> via <code>--respect-gitignore</code>, and protect against writing inside the   source tree.</li> <li>Extend single-file and directory commands with stdin/stdout streaming, fail-fast   options (<code>--fail-on-change</code>, <code>--fail-on-bailout</code>, <code>--fail-on-error</code>), and unwritable   output detection.</li> <li>Add CLI tests covering encoding preservation, glob behaviour, JSON output failure   cases, gitignore integration, and parallel traversal reporting helpers.</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to tsrs","text":"<p>Thank you for your interest in contributing to tsrs (Tree-Shaking in Rust for Python)! This document outlines the process for contributing to the project.</p>"},{"location":"CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and collaborative. We're building a tool to make Python deployments better for everyone.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.75+ (check with <code>rustc --version</code>)</li> <li>Python 3.8+ (for testing)</li> <li>Git</li> </ul>"},{"location":"CONTRIBUTING/#local-development-setup","title":"Local Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/GeorgePearse/tsrs.git\ncd tsrs\n\n# Build the project\ncargo build --release\n\n# Run tests\ncargo test\n\n# Run linting and formatting\ncargo fmt\ncargo clippy -- -W clippy::pedantic\n\n# Check the pre-commit hook runs successfully\n./target/release/tsrs-cli --help\n</code></pre>"},{"location":"CONTRIBUTING/#making-changes","title":"Making Changes","text":""},{"location":"CONTRIBUTING/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a feature branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes with clear, focused commits    <pre><code>git add &lt;files&gt;\ngit commit -m \"Description of changes\"\n</code></pre></p> </li> <li> <p>Ensure code quality <pre><code># Format code\ncargo fmt\n\n# Run linting (this runs automatically in pre-commit hook)\ncargo clippy -- -W clippy::pedantic\n\n# Run tests\ncargo test\n</code></pre></p> </li> <li> <p>Push and open a PR <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"CONTRIBUTING/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<ul> <li>Use clear, descriptive messages</li> <li>Start with a verb (Add, Fix, Refactor, etc.)</li> <li>Reference issues when relevant: <code>Fixes #123</code></li> <li>Example: <code>Add support for nested function analysis in minify module</code></li> </ul>"},{"location":"CONTRIBUTING/#testing-requirements","title":"Testing Requirements","text":"<p>All contributions must include tests:</p> <pre><code># Run all tests\ncargo test\n\n# Run tests with output\ncargo test -- --nocapture\n\n# Run specific test\ncargo test test_name\n</code></pre>"},{"location":"CONTRIBUTING/#code-standards","title":"Code Standards","text":""},{"location":"CONTRIBUTING/#style-guide","title":"Style Guide","text":"<ul> <li>Formatting: Use <code>cargo fmt</code> (enforced via pre-commit hook)</li> <li>Linting: Must pass <code>cargo clippy -- -W clippy::pedantic</code></li> <li>Documentation: Add doc comments to public APIs   <pre><code>/// Brief description\n///\n/// Longer explanation if needed.\n///\n/// # Errors\n///\n/// Describe what errors this function can return.\npub fn my_function() -&gt; Result&lt;T&gt; {\n    // ...\n}\n</code></pre></li> </ul>"},{"location":"CONTRIBUTING/#type-safety","title":"Type Safety","text":"<ul> <li>Write fully typed Python code for Rust implementations</li> <li>Use type annotations in all function signatures</li> <li>Leverage Rust's type system for compile-time safety</li> </ul>"},{"location":"CONTRIBUTING/#project-structure","title":"Project Structure","text":"<pre><code>tsrs/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs              # Library root, public API\n\u2502   \u251c\u2500\u2500 bin/cli.rs          # CLI binary\n\u2502   \u251c\u2500\u2500 venv.rs             # Virtual environment analysis\n\u2502   \u251c\u2500\u2500 imports.rs          # Import statement extraction\n\u2502   \u251c\u2500\u2500 callgraph.rs        # Function call graph analysis\n\u2502   \u251c\u2500\u2500 slim.rs             # Venv slimming implementation\n\u2502   \u251c\u2500\u2500 minify.rs           # Local variable minification\n\u2502   \u251c\u2500\u2500 error.rs            # Error types\n\u2502   \u2514\u2500\u2500 lib.rs              # Library entry point\n\u251c\u2500\u2500 tests/                  # Integration tests\n\u251c\u2500\u2500 Cargo.toml              # Manifest\n\u251c\u2500\u2500 README.md               # Project overview\n\u251c\u2500\u2500 CONTRIBUTING.md         # This file\n\u251c\u2500\u2500 MINIFY_DESIGN.md        # Minify algorithm details\n\u251c\u2500\u2500 TESTING.md              # Testing guide\n\u2514\u2500\u2500 TEST_REPOS_SUMMARY.md   # Test repository documentation\n</code></pre>"},{"location":"CONTRIBUTING/#key-modules","title":"Key Modules","text":""},{"location":"CONTRIBUTING/#venvrs","title":"venv.rs","text":"<p>Analyzes Python virtual environments to discover installed packages and their metadata.</p>"},{"location":"CONTRIBUTING/#importsrs","title":"imports.rs","text":"<p>Parses Python source code to extract <code>import</code> and <code>from...import</code> statements. Uses rustpython-parser for AST analysis.</p>"},{"location":"CONTRIBUTING/#callgraphrs","title":"callgraph.rs","text":"<p>Builds a call graph of functions within packages to identify unused/dead code.</p>"},{"location":"CONTRIBUTING/#slimrs","title":"slim.rs","text":"<p>Creates minimal virtual environments by analyzing code imports and copying only used packages.</p>"},{"location":"CONTRIBUTING/#minifyrs","title":"minify.rs","text":"<p>Implements safe local variable renaming for Python code (minification) while preserving correctness.</p>"},{"location":"CONTRIBUTING/#architecture-decisions","title":"Architecture Decisions","text":""},{"location":"CONTRIBUTING/#high-precision-low-recall-philosophy","title":"High Precision, Low Recall Philosophy","text":"<p>We prioritize correctness over comprehensiveness:</p> <ul> <li>Never remove code unless we're absolutely certain it's unused</li> <li>Keep module-level exports (they may be used externally)</li> <li>Preserve public APIs even if not directly called</li> <li>Be conservative with dynamic features and reflection</li> </ul>"},{"location":"CONTRIBUTING/#error-handling","title":"Error Handling","text":"<ul> <li>Use <code>Result&lt;T&gt;</code> for fallible operations</li> <li>Provide context in error messages</li> <li>Use custom error types via <code>thiserror</code></li> </ul>"},{"location":"CONTRIBUTING/#documentation","title":"Documentation","text":"<p>When adding features, update relevant documentation:</p> <ul> <li>Code comments: Explain the \"why\" not the \"what\"</li> <li>Doc comments: Public API documentation</li> <li>README.md: Update usage examples</li> <li>MINIFY_DESIGN.md: Algorithm or design details</li> <li>TESTING.md: How to test your feature</li> </ul>"},{"location":"CONTRIBUTING/#performance-considerations","title":"Performance Considerations","text":"<p>The project uses: - rayon: Parallel processing for directory operations - rustpython-parser: Fast Python AST parsing - regex: Pattern matching for import statements - walkdir: Efficient directory traversal</p> <p>When optimizing: 1. Profile first with <code>cargo flamegraph</code> 2. Benchmark changes: <code>cargo bench</code> 3. Consider parallelization opportunities</p>"},{"location":"CONTRIBUTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"CONTRIBUTING/#pre-commit-hook-failures","title":"Pre-commit Hook Failures","text":"<p>If the clippy pre-commit hook fails:</p> <pre><code># Run clippy manually to see detailed output\ncargo clippy -- -W clippy::pedantic\n\n# Fix issues or suppress with #[allow(...)] if justified\n# Then try committing again\n</code></pre>"},{"location":"CONTRIBUTING/#test-failures","title":"Test Failures","text":"<pre><code># Run tests with backtrace\nRUST_BACKTRACE=1 cargo test\n\n# Run specific failing test\ncargo test failing_test_name -- --nocapture\n</code></pre>"},{"location":"CONTRIBUTING/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: See README.md, MINIFY_DESIGN.md, TESTING.md</li> <li>Issues: Open an issue on GitHub with details</li> <li>Discussions: Use GitHub Discussions for questions</li> </ul>"},{"location":"CONTRIBUTING/#recognition","title":"Recognition","text":"<p>Contributors will be recognized in the project's CONTRIBUTORS file (once created).</p>"},{"location":"CONTRIBUTING/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the same license as the project (TBD).</p> <p>Thank you for making tsrs better! \ud83d\ude80</p>"},{"location":"MINIFY_DESIGN/","title":"Python Minification Design","text":""},{"location":"MINIFY_DESIGN/#overview","title":"Overview","text":"<p>Scope-aware local renaming for functions using rustpython_parser AST. Collects function-local bindings and generates short names (a, b, c...) while respecting Python scoping rules.</p>"},{"location":"MINIFY_DESIGN/#core-data-structures","title":"Core Data Structures","text":""},{"location":"MINIFY_DESIGN/#functionplan","title":"FunctionPlan","text":"<pre><code>use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FunctionPlan {\n    /// Function name (for debugging/tracking)\n    pub name: String,\n\n    /// Original names in function scope (sorted for stability)\n    pub local_names: Vec&lt;String&gt;,\n\n    /// Mapping from original name to minified name\n    pub rename_map: HashMap&lt;String, String&gt;,\n\n    /// Names that cannot be renamed (globals, nonlocals, builtins, keywords)\n    pub excluded_names: Vec&lt;String&gt;,\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#minifyplan","title":"MinifyPlan","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MinifyPlan {\n    /// Function plans in stable order (by source position)\n    pub functions: Vec&lt;FunctionPlan&gt;,\n\n    /// Python keywords that must never be renamed\n    pub python_keywords: Vec&lt;String&gt;,\n\n    /// Builtin names that should not be renamed\n    pub builtins: Vec&lt;String&gt;,\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#short-name-generator","title":"Short Name Generator","text":"<p>Simple sequential generator: a, b, c, ..., z, aa, ab, ..., zz, aaa, ...</p> <pre><code>pub struct ShortNameGen {\n    counter: usize,\n}\n\nimpl ShortNameGen {\n    pub fn new() -&gt; Self {\n        Self { counter: 0 }\n    }\n\n    pub fn next(&amp;mut self, keywords: &amp;[String]) -&gt; String {\n        loop {\n            let name = Self::generate(self.counter);\n            self.counter += 1;\n\n            if !keywords.contains(&amp;name) {\n                return name;\n            }\n        }\n    }\n\n    fn generate(n: usize) -&gt; String {\n        let mut num = n;\n        let mut result = String::new();\n\n        loop {\n            result.push((b'a' + (num % 26) as u8) as char);\n            num /= 26;\n            if num == 0 {\n                break;\n            }\n            num -= 1;\n        }\n\n        result.chars().rev().collect()\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#python-keywords-complete-list","title":"Python Keywords (Complete List)","text":"<p>Never rename these 35 keywords:</p> <pre><code>const PYTHON_KEYWORDS: &amp;[&amp;str] = &amp;[\n    \"False\", \"None\", \"True\", \"and\", \"as\", \"assert\", \"async\", \"await\",\n    \"break\", \"class\", \"continue\", \"def\", \"del\", \"elif\", \"else\", \"except\",\n    \"finally\", \"for\", \"from\", \"global\", \"if\", \"import\", \"in\", \"is\",\n    \"lambda\", \"nonlocal\", \"not\", \"or\", \"pass\", \"raise\", \"return\",\n    \"try\", \"while\", \"with\", \"yield\",\n];\n</code></pre>"},{"location":"MINIFY_DESIGN/#ast-node-types-for-binding-collection","title":"AST Node Types for Binding Collection","text":""},{"location":"MINIFY_DESIGN/#1-function-parameters","title":"1. Function Parameters","text":"<pre><code>// ast::StmtFunctionDef, ast::StmtAsyncFunctionDef\nparameters: Parameters {\n    posonlyargs: Vec&lt;ParameterWithDefault&gt;,  // positional-only\n    args: Vec&lt;ParameterWithDefault&gt;,         // normal params\n    vararg: Option&lt;Parameter&gt;,               // *args\n    kwonlyargs: Vec&lt;ParameterWithDefault&gt;,   // keyword-only\n    kwarg: Option&lt;Parameter&gt;,                // **kwargs\n}\n\n// Extract: .arg (Identifier) from each Parameter\n</code></pre>"},{"location":"MINIFY_DESIGN/#2-assignment-targets","title":"2. Assignment Targets","text":"<pre><code>// ast::StmtAssign\ntargets: Vec&lt;Expr&gt;  // Can be Name, Tuple, List, Subscript, Attribute\n\n// ast::StmtAnnAssign\ntarget: Expr\n\n// ast::StmtAugAssign\ntarget: Expr\n\n// Extract Name nodes: Expr::Name(ExprName { id, .. }) -&gt; id\n</code></pre>"},{"location":"MINIFY_DESIGN/#3-for-loop-targets","title":"3. For Loop Targets","text":"<pre><code>// ast::StmtFor, ast::StmtAsyncFor\ntarget: Expr  // Can be Name, Tuple, List\n\n// Extract Name nodes recursively from target\n</code></pre>"},{"location":"MINIFY_DESIGN/#4-with-statement-targets","title":"4. With Statement Targets","text":"<pre><code>// ast::StmtWith, ast::StmtAsyncWith\nitems: Vec&lt;WithItem&gt; {\n    context_expr: Expr,\n    optional_vars: Option&lt;Expr&gt;,  // Extract Name from this\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#5-exception-handler-names","title":"5. Exception Handler Names","text":"<pre><code>// ast::ExceptHandler::ExceptHandler\nname: Option&lt;Identifier&gt;  // The 'e' in 'except Error as e'\n</code></pre>"},{"location":"MINIFY_DESIGN/#6-import-aliases","title":"6. Import Aliases","text":"<pre><code>// ast::StmtImport\nnames: Vec&lt;Alias&gt; {\n    name: Identifier,\n    asname: Option&lt;Identifier&gt;,  // Use asname if present, else name\n}\n\n// ast::StmtImportFrom\nnames: Vec&lt;Alias&gt;  // Same structure\n</code></pre>"},{"location":"MINIFY_DESIGN/#name-extraction-algorithm","title":"Name Extraction Algorithm","text":"<pre><code>pub fn extract_names(expr: &amp;Expr) -&gt; Vec&lt;String&gt; {\n    match expr {\n        Expr::Name(ExprName { id, .. }) =&gt; vec![id.to_string()],\n\n        Expr::Tuple(ExprTuple { elts, .. }) |\n        Expr::List(ExprList { elts, .. }) =&gt; {\n            elts.iter()\n                .flat_map(|e| extract_names(e))\n                .collect()\n        }\n\n        // Subscript/Attribute don't bind new names\n        _ =&gt; vec![],\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#exclusion-rules","title":"Exclusion Rules","text":""},{"location":"MINIFY_DESIGN/#exclude-from-renaming","title":"Exclude from renaming:","text":"<ol> <li>Keywords: All 35 Python keywords</li> <li>Builtins: Common builtins (configurable list)</li> <li>Global declarations: Names in <code>global</code> statements</li> <li>Nonlocal declarations: Names in <code>nonlocal</code> statements</li> <li>Class-scoped names: Do not process class bodies</li> <li>Single underscores: <code>_</code> (convention for unused variables)</li> <li>Dunder names: <code>__name__</code>, <code>__init__</code>, etc.</li> </ol>"},{"location":"MINIFY_DESIGN/#detection","title":"Detection:","text":"<pre><code>pub fn should_exclude(name: &amp;str) -&gt; bool {\n    name == \"_\" ||\n    name.starts_with(\"__\") &amp;&amp; name.ends_with(\"__\") ||\n    PYTHON_KEYWORDS.contains(&amp;name)\n}\n\npub fn collect_global_nonlocal(body: &amp;[Stmt]) -&gt; Vec&lt;String&gt; {\n    body.iter()\n        .filter_map(|stmt| match stmt {\n            Stmt::Global(g) =&gt; Some(g.names.iter()),\n            Stmt::Nonlocal(n) =&gt; Some(n.names.iter()),\n            _ =&gt; None,\n        })\n        .flatten()\n        .map(|id| id.to_string())\n        .collect()\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#collection-algorithm","title":"Collection Algorithm","text":"<pre><code>pub fn collect_function_bindings(func: &amp;StmtFunctionDef) -&gt; FunctionPlan {\n    let mut bindings = Vec::new();\n    let mut excluded = Vec::new();\n\n    // 1. Collect global/nonlocal declarations\n    let protected = collect_global_nonlocal(&amp;func.body);\n    excluded.extend(protected.clone());\n\n    // 2. Collect parameters\n    collect_params(&amp;func.parameters, &amp;mut bindings);\n\n    // 3. Traverse body for assignments, loops, withs, excepts, imports\n    collect_from_body(&amp;func.body, &amp;mut bindings, &amp;protected);\n\n    // 4. Remove excluded patterns\n    bindings.retain(|name| !should_exclude(name) &amp;&amp; !protected.contains(name));\n\n    // 5. Sort for stability\n    bindings.sort();\n    bindings.dedup();\n\n    // 6. Generate rename map\n    let mut gen = ShortNameGen::new();\n    let mut rename_map = HashMap::new();\n\n    for name in &amp;bindings {\n        let short = gen.next(&amp;PYTHON_KEYWORDS.iter().map(|s| s.to_string()).collect::&lt;Vec&lt;_&gt;&gt;());\n        rename_map.insert(name.clone(), short);\n    }\n\n    FunctionPlan {\n        name: func.name.to_string(),\n        local_names: bindings,\n        rename_map,\n        excluded_names: excluded,\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#scope-rules","title":"Scope Rules","text":""},{"location":"MINIFY_DESIGN/#include-in-function-scope","title":"Include in function scope:","text":"<ul> <li>Function parameters (all types)</li> <li>Assignment targets (direct names only, not attributes/subscripts)</li> <li>For/AsyncFor targets</li> <li>With/AsyncWith optional_vars</li> <li>ExceptHandler names</li> <li>Import/ImportFrom aliases (the asname or name)</li> </ul>"},{"location":"MINIFY_DESIGN/#exclude-from-function-scope","title":"Exclude from function scope:","text":"<ul> <li>Class definitions (process separately, not recursively)</li> <li>Nested function definitions (process separately)</li> <li>Global/nonlocal declared names</li> <li>Attribute access (obj.attr - only rename obj)</li> <li>Subscript access (obj[key] - only rename obj/key)</li> </ul>"},{"location":"MINIFY_DESIGN/#stable-function-order","title":"Stable Function Order","text":"<p>Collect functions in source order:</p> <pre><code>pub fn collect_functions_stable(module: &amp;ast::Mod) -&gt; Vec&lt;&amp;StmtFunctionDef&gt; {\n    let mut funcs = Vec::new();\n\n    match module {\n        ast::Mod::Module(m) =&gt; visit_stmts_for_functions(&amp;m.body, &amp;mut funcs),\n        ast::Mod::Expression(_) =&gt; {},\n    }\n\n    funcs  // Already in source order\n}\n\nfn visit_stmts_for_functions&lt;'a&gt;(\n    stmts: &amp;'a [Stmt],\n    funcs: &amp;mut Vec&lt;&amp;'a StmtFunctionDef&gt;,\n) {\n    for stmt in stmts {\n        match stmt {\n            Stmt::FunctionDef(f) =&gt; funcs.push(f),\n            Stmt::AsyncFunctionDef(f) =&gt; {\n                // Convert async to sync representation if needed\n            }\n            Stmt::ClassDef(c) =&gt; {\n                // Don't recurse into class bodies\n            }\n            // Don't recurse into nested scopes\n            _ =&gt; {}\n        }\n    }\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#serialization-example","title":"Serialization Example","text":"<pre><code>{\n  \"functions\": [\n    {\n      \"name\": \"calculate\",\n      \"local_names\": [\"result\", \"temp\", \"value\"],\n      \"rename_map\": {\n        \"result\": \"a\",\n        \"temp\": \"b\",\n        \"value\": \"c\"\n      },\n      \"excluded_names\": [\"global_config\"]\n    }\n  ],\n  \"python_keywords\": [\"False\", \"None\", \"True\", ...],\n  \"builtins\": [\"print\", \"len\", \"range\", ...]\n}\n</code></pre>"},{"location":"MINIFY_DESIGN/#implementation-checklist","title":"Implementation Checklist","text":"<ul> <li>[ ] Define <code>FunctionPlan</code> and <code>MinifyPlan</code> structs with serde</li> <li>[ ] Implement <code>ShortNameGen</code> with tests</li> <li>[ ] Create <code>PYTHON_KEYWORDS</code> constant</li> <li>[ ] Implement <code>extract_names()</code> for recursive name extraction</li> <li>[ ] Implement <code>should_exclude()</code> filter</li> <li>[ ] Implement <code>collect_global_nonlocal()</code></li> <li>[ ] Implement parameter collection</li> <li>[ ] Implement body traversal for all binding forms</li> <li>[ ] Implement stable function ordering</li> <li>[ ] Add comprehensive tests for each AST node type</li> <li>[ ] Verify serialization round-trip</li> </ul>"},{"location":"MINIFY_DESIGN/#edge-cases","title":"Edge Cases","text":"<ol> <li>Tuple unpacking: <code>a, b = foo()</code> - extract both <code>a</code> and <code>b</code></li> <li>Nested unpacking: <code>a, (b, c) = foo()</code> - extract <code>a</code>, <code>b</code>, <code>c</code></li> <li>Walrus operator: <code>:=</code> creates bindings in expressions (handle carefully)</li> <li>List comprehension variables: Lexically scoped, don't leak (skip)</li> <li>Match patterns: Variable bindings in match cases (include)</li> <li>Type parameters (3.12+): Generic type vars (include if present)</li> </ol>"},{"location":"MINIFY_DESIGN/#notes","title":"Notes","text":"<ul> <li>This design focuses on planning only - no AST rewriting</li> <li>Output is JSON-serializable for external tools</li> <li>Function order is deterministic (source position)</li> <li>Name collisions avoided by checking keywords in generator</li> <li>Class scope deliberately excluded (different minification strategy needed)</li> </ul>"},{"location":"MINIFY_DESIGN/#references","title":"References","text":"<ul> <li>pyminifier (liftoffsoftware)</li> <li>TreeShaker (sclabs)</li> <li>\u201cBuild a Python tree-shaker in Rust\u201d (dev.to)</li> <li>\u201cCrude Python tree-shaking for squeezing into AWS Lambda package size limits\u201d (sam152)</li> </ul>"},{"location":"TESTING/","title":"Testing tsrs (Tree-Shaking in Rust for Python)","text":""},{"location":"TESTING/#overview","title":"Overview","text":"<p>The test infrastructure validates that tsrs correctly slims virtual environments without breaking functionality.</p>"},{"location":"TESTING/#test-strategy","title":"Test Strategy","text":"<p>High Precision, Low Recall Philosophy: We validate that after tree-shaking, the application still works perfectly. This ensures we're not removing code that's actually used.</p>"},{"location":"TESTING/#the-test-flow","title":"The Test Flow","text":"<p>For each test repository:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. Create Full venv                \u2502\n\u2502  2. Install all dependencies        \u2502\n\u2502  3. Run functionality tests \u2713        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  4. Run tsrs                        \u2502\n\u2502  5. Create .venv-slim with only     \u2502\n\u2502     the packages that are imported  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  6. Run same tests with .venv-slim  \u2502\n\u2502  7. Verify all tests still pass \u2713   \u2502\n\u2502  8. Report size savings             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"TESTING/#test-repositories","title":"Test Repositories","text":""},{"location":"TESTING/#1-simple-data","title":"1. simple-data","text":"<ul> <li>Dependencies: requests, click, pydantic</li> <li>Purpose: Tests HTTP, CLI, and validation libraries</li> <li>Test: Validates imports and Pydantic model functionality</li> </ul>"},{"location":"TESTING/#2-cli-tool","title":"2. cli-tool","text":"<ul> <li>Dependencies: typer, rich</li> <li>Purpose: Tests CLI framework and output libraries</li> <li>Test: Validates typer and rich functionality</li> </ul>"},{"location":"TESTING/#how-to-add-more-tests","title":"How to Add More Tests","text":"<p>Create a new test repo:</p> <pre><code>mkdir test_repos/my-test\ncd test_repos/my-test\ngit init\n\n# Create pyproject.toml with dependencies\n# Create Python code that uses those dependencies\n# Create test.sh that validates everything works\n# Commit\n\ngit add -A\ngit commit -m \"Initial test repo\"\n</code></pre> <p>The test runner will auto-discover it.</p>"},{"location":"TESTING/#running-tests","title":"Running Tests","text":""},{"location":"TESTING/#prerequisites","title":"Prerequisites","text":"<pre><code># Build the CLI\ncargo build --release --bin tsrs-cli\n\n# Ensure Python 3.7+ is available\npython --version\n</code></pre>"},{"location":"TESTING/#run-all-tests","title":"Run All Tests","text":"<pre><code>cd test_repos\nbash run_tests.sh\n</code></pre>"},{"location":"TESTING/#run-single-test","title":"Run Single Test","text":"<pre><code>cd test_repos/simple-data\npython -m venv .venv\n.venv/bin/pip install -q -e .\n.venv/bin/python test.sh\n\n# Then manually:\n../../target/release/tsrs-cli slim . .venv -o .venv-slim\nVIRTUAL_ENV=.venv-slim .venv-slim/bin/python test.sh\n</code></pre>"},{"location":"TESTING/#what-gets-tested","title":"What Gets Tested","text":"<p>\u2705 Functionality: Application code works identically before/after \u2705 Imports: All imported packages are available \u2705 Size Reduction: Quantifies how much space is saved \u2705 Safety: Validates nothing critical was removed  </p>"},{"location":"TESTING/#success-criteria","title":"Success Criteria","text":"<p>Each test is considered successful if:</p> <ol> <li>\u2705 Original venv tests pass</li> <li>\u2705 tree-shaking completes without error</li> <li>\u2705 Slimmed venv tests pass (same test, slimmer environment)</li> <li>\u2705 Size reduction is meaningful (typically 30-70% smaller)</li> </ol>"},{"location":"TESTING/#expected-results","title":"Expected Results","text":"<p>When you run the test suite, you should see:</p> <pre><code>==================================================\ntsrs Test Runner\n==================================================\n\n==================================================\nTesting: simple-data\n==================================================\n[1/5] Creating virtual environment...\n[2/5] Installing dependencies...\n[3/5] Running test (before slimming)...\n\u2713 Before test passed\n[4/5] Running tree-shaking...\n\u2713 Tree-shaking completed\n[5/5] Running test (after slimming)...\n\u2713 After test passed\n\nSize comparison:\n  Original: 145M\n  Slimmed:  65M\n\n==================================================\nTesting: cli-tool\n==================================================\n[1/5] Creating virtual environment...\n[2/5] Installing dependencies...\n[3/5] Running test (before slimming)...\n\u2713 Before test passed\n[4/5] Running tree-shaking...\n\u2713 Tree-shaking completed\n[5/5] Running test (after slimming)...\n\u2713 After test passed\n\nSize comparison:\n  Original: 120M\n  Slimmed:  52M\n\n==================================================\nSummary\n==================================================\nPassed: 2\nFailed: 0\n==================================================\n\u2713 All tests passed!\n</code></pre>"},{"location":"TESTING/#troubleshooting","title":"Troubleshooting","text":""},{"location":"TESTING/#test-fails-with-testsh-not-found","title":"Test fails with \"test.sh not found\"","text":"<p>Make sure your test repo has an executable <code>test.sh</code> file.</p>"},{"location":"TESTING/#original-venv-test-fails","title":"Original venv test fails","text":"<p>Install dependencies with: <code>.venv/bin/pip install -e .</code></p>"},{"location":"TESTING/#slimmed-venv-test-fails","title":"Slimmed venv test fails","text":"<p>This indicates tsrs removed a package that's actually needed. This is the high-precision validation working - it caught a false positive.</p>"},{"location":"TESTING/#check-what-was-removed","title":"Check what was removed","text":"<pre><code>ls .venv/lib/python*/site-packages\nls .venv-slim/lib/python*/site-packages\n# Compare the two\n</code></pre>"},{"location":"TESTING/#philosophy","title":"Philosophy","text":"<p>Better to keep unused code than break working code.</p> <p>The test suite proves this philosophy works in practice: - We leave room for indirect usage patterns - We preserve all public APIs - We validate that real applications work after slimming - We prioritize correctness over aggressive optimization</p>"},{"location":"TEST_REPOS_SUMMARY/","title":"Test Repositories Summary","text":""},{"location":"TEST_REPOS_SUMMARY/#overview","title":"Overview","text":"<p>The <code>test_repos</code> directory contains 5 diverse Python projects that validate tsrs works correctly across classic Python libraries and use cases.</p>"},{"location":"TEST_REPOS_SUMMARY/#the-5-test-repos","title":"The 5 Test Repos","text":""},{"location":"TEST_REPOS_SUMMARY/#1-simple-data","title":"1. simple-data","text":"<p>Purpose: HTTP requests, CLI interfaces, and data validation Dependencies: requests, click, pydantic What it tests: - HTTP library imports - CLI framework (Click) - Pydantic model validation - Data model instantiation</p> <p>Expected size reduction: 30-40%</p>"},{"location":"TEST_REPOS_SUMMARY/#2-cli-tool","title":"2. cli-tool","text":"<p>Purpose: CLI application framework and formatted output Dependencies: typer, rich What it tests: - Typer decorators and command routing - Rich table rendering - Rich console styling - CLI argument parsing</p> <p>Expected size reduction: 25-35%</p>"},{"location":"TEST_REPOS_SUMMARY/#3-pandas-analysis-new","title":"3. pandas-analysis \u2728 NEW","text":"<p>Purpose: Data analysis and scientific computing Dependencies: pandas, numpy What it tests: - Pandas DataFrame operations - NumPy array operations - DataFrame aggregation (groupby) - Statistical calculations (mean, std, min, max)</p> <p>Expected size reduction: 40-50%</p> <p>Classic Python library for data science - one of the largest packages</p>"},{"location":"TEST_REPOS_SUMMARY/#4-ml-classifier-new","title":"4. ml-classifier \u2728 NEW","text":"<p>Purpose: Machine learning model training and evaluation Dependencies: scikit-learn, numpy What it tests: - Dataset generation - Model training (Random Forest) - Cross-validation and train/test split - Performance metrics (accuracy, precision, recall) - Tree-based ensemble methods</p> <p>Expected size reduction: 45-55%</p> <p>Tests the complex scikit-learn ecosystem with lots of submodules</p>"},{"location":"TEST_REPOS_SUMMARY/#5-data-viz-new","title":"5. data-viz \u2728 NEW","text":"<p>Purpose: Data visualization and plotting Dependencies: matplotlib, seaborn, pandas What it tests: - Matplotlib figure creation and plotting - Matplotlib pyplot interface - Seaborn statistical plotting - Multiple plot types (line, scatter, histogram) - Color mapping and legend handling</p> <p>Expected size reduction: 35-45%</p> <p>Tests visualization libraries with heavy dependencies</p>"},{"location":"TEST_REPOS_SUMMARY/#why-these-5-repos","title":"Why These 5 Repos?","text":"<p>These repos represent classic Python ecosystem projects:</p> Domain Library Repo Data Science pandas, numpy, matplotlib, seaborn pandas-analysis, data-viz Machine Learning scikit-learn ml-classifier Web/HTTP requests, fastapi simple-data, web-api CLI Tools click, typer, rich simple-data, cli-tool Validation pydantic simple-data, web-api <p>Together they cover: - \u2705 The full PyData ecosystem - \u2705 Complex dependency trees (pandas, sklearn have 20+ sub-dependencies) - \u2705 Different package types (frameworks, libraries, utilities) - \u2705 Real-world usage patterns - \u2705 Significant size reduction opportunities</p>"},{"location":"TEST_REPOS_SUMMARY/#running-the-tests","title":"Running the Tests","text":""},{"location":"TEST_REPOS_SUMMARY/#quick-start","title":"Quick Start","text":"<pre><code># Build tsrs\ncargo build --release --bin tsrs-cli\n\n# Run all 5 tests\ncd test_repos\nbash run_tests.sh\n</code></pre>"},{"location":"TEST_REPOS_SUMMARY/#expected-output","title":"Expected Output","text":"<pre><code>==================================================\nTesting: simple-data\n==================================================\n[1/5] Creating virtual environment...\n[2/5] Installing dependencies...\n[3/5] Running test (before slimming)...\n\u2713 Before test passed\n[4/5] Running tree-shaking...\n\u2713 Tree-shaking completed\n[5/5] Running test (after slimming)...\n\u2713 After test passed\n\nSize comparison:\n  Original: 145M\n  Slimmed:  95M\n\n==================================================\nTesting: cli-tool\n==================================================\n... (similar for each repo)\n\n==================================================\nSummary\n==================================================\nPassed: 5\nFailed: 0\n==================================================\n\u2713 All tests passed!\n</code></pre>"},{"location":"TEST_REPOS_SUMMARY/#what-gets-validated","title":"What Gets Validated","text":"<p>For each test repo, the test suite validates:</p> <ol> <li>Original venv works \u2713</li> <li>All dependencies install correctly</li> <li>Imports work</li> <li> <p>Functionality passes tests</p> </li> <li> <p>Tree-shaking completes \u2713</p> </li> <li>tsrs analyzes the code</li> <li>Creates <code>.venv-slim</code> with only used packages</li> <li> <p>No errors during slimming</p> </li> <li> <p>Slimmed venv still works \u2713</p> </li> <li>Same test.sh passes with slim venv</li> <li>All imported packages are available</li> <li>Functionality unchanged</li> <li> <p>This is the critical validation</p> </li> <li> <p>Size reduction is real \u2713</p> </li> <li>Shows before/after sizes</li> <li>Typically 30-55% reduction</li> </ol>"},{"location":"TEST_REPOS_SUMMARY/#success-criteria","title":"Success Criteria","text":"<p>All tests pass if: - \u2705 Original venv tests pass - \u2705 Tree-shaking completes without error - \u2705 Slimmed venv tests pass - \u2705 Size reduction is 25%+ (validated)</p>"},{"location":"TEST_REPOS_SUMMARY/#why-this-approach-works","title":"Why This Approach Works","text":"<p>High Precision Testing: By running the same test suite before and after slimming, we prove that: 1. We didn't remove anything the code actually uses 2. The slimmed venv is fully functional 3. Size savings are real and validated</p> <p>Representative Coverage: These 5 repos use: - 10+ major Python packages - 50+ sub-dependencies - Different import patterns - Different coding styles</p> <p>Safe by Design: If tree-shaking works correctly on these diverse repos, it will work on most Python projects.</p>"},{"location":"TEST_REPOS_SUMMARY/#adding-more-test-repos","title":"Adding More Test Repos","text":"<p>To add a new test repo:</p> <pre><code>mkdir test_repos/my-repo\ncd test_repos/my-repo\ngit init\n\n# Create:\n# - pyproject.toml (with dependencies)\n# - Python files (your application)\n# - test.sh (validation script)\n\ngit add -A\ngit commit -m \"Initial test repo\"\n</code></pre> <p>The test runner will auto-discover it on next run.</p>"},{"location":"TEST_REPOS_SUMMARY/#files-structure","title":"Files Structure","text":"<pre><code>test_repos/\n\u251c\u2500\u2500 simple-data/              # Simple data processing\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 cli-tool/                 # CLI application\n\u2502   \u251c\u2500\u2500 app.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 pandas-analysis/          # Data analysis \u2728 NEW\n\u2502   \u251c\u2500\u2500 analysis.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 ml-classifier/            # ML training \u2728 NEW\n\u2502   \u251c\u2500\u2500 classifier.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 data-viz/                 # Visualization \u2728 NEW\n\u2502   \u251c\u2500\u2500 visualizer.py\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 test.sh\n\u251c\u2500\u2500 run_tests.sh              # Master test runner\n\u2514\u2500\u2500 README.md                 # Documentation\n</code></pre>"},{"location":"TEST_REPOS_SUMMARY/#reference","title":"Reference","text":"<p>See <code>TESTING.md</code> in the root for comprehensive testing documentation. See <code>test_repos/README.md</code> for detailed test repo information.</p>"}]}